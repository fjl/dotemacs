;;; logview.el --- Major mode for viewing log files  -*- lexical-binding: t -*-

;; Copyright (C) 2015-2017 Paul Pogonyshev

;; Author:     Paul Pogonyshev <pogonyshev@gmail.com>
;; Maintainer: Paul Pogonyshev <pogonyshev@gmail.com>
;; Version:    0.8.2
;; Package-Version: 20170928.820
;; Keywords:   files, tools
;; Homepage:   https://github.com/doublep/logview
;; Package-Requires: ((emacs "24.1") (datetime "0.3"))

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see http://www.gnu.org/licenses.


;;; Commentary:

;; Logview mode provides syntax highlighting, filtering and other
;; features for various log files.  The main target are files similar
;; to ones generated by Log4j, Logback and other Java logging
;; libraries, but there is really nothing Java-specific in the mode
;; and it should work just fine with any log that follows similar
;; structure, probably after some configuration.


;;; Code:

(eval-when-compile (require 'cl-lib))
(require 'datetime)

;; We _append_ self to the list of mode rules so as to not clobber
;; other rules, as '.log' is a common file extension.  This also gives
;; the user an easy way to prevent 'logview' from being autoselected.
;;;###autoload
(add-to-list 'auto-mode-alist '("\\.log\\(?:\\.[0-9]+\\)?\\'" . logview-mode) t)



;;; Public variables.
;; This needs to go before customization, since the values are used in
;; compound widget types.

(defvar logview-std-submodes
  '(("SLF4J" . ((format  . "TIMESTAMP [THREAD] LEVEL NAME -")
                (levels  . "SLF4J")
                (aliases . ("Log4j" "Log4j2" "Logback"))))
    ;; We misuse thread as a field for hostname.
    ("UNIX"  . ((format  . "TIMESTAMP THREAD NAME:"))))
  "Alist of standard submodes.
This value is used as the fallback for customizable
`logview-additional-submodes'.")

(defvar logview-std-level-mappings
  '(("SLF4J" . ((error       "ERROR")
                (warning     "WARN")
                (information "INFO")
                (debug       "DEBUG")
                (trace       "TRACE")
                (aliases     "Log4j" "Log4j2" "Logback")))
    ("JUL"   . ((error       "SEVERE")
                (warning     "WARNING")
                (information "INFO")
                (debug       "CONFIG" "FINE")
                (trace       "FINER" "FINEST"))))
  "Standard mappings of actual log levels to mode's final levels.
This alist value is used as the fallback for customizable
`logview-additional-level-mappings'.")

(defvar logview-std-timestamp-formats
  (let (formats)
    (dolist (data '(("ISO 8601 datetime + millis"             "yyyy-MM-dd HH:mm:ss.SSS")
                    ("ISO 8601 datetime + micros"             "yyyy-MM-dd HH:mm:ss.SSSSSS")
                    ("ISO 8601 datetime"                      "yyyy-MM-dd HH:mm:ss")
                    ("ISO 8601 datetime (with 'T') + millis"  "yyyy-MM-dd'T'HH:mm:ss.SSS")
                    ("ISO 8601 datetime (with 'T') + micros"  "yyyy-MM-dd'T'HH:mm:ss.SSSSSS")
                    ("ISO 8601 datetime (with 'T')"           "yyyy-MM-dd'T'HH:mm:ss")
                    ("ISO 8601 time only + millis"            "HH:mm:ss.SSS")
                    ("ISO 8601 time only + micros"            "HH:mm:ss.SSSSSS")
                    ("ISO 8601 time only"                     "HH:mm:ss")
                    (nil                                      "MMM d HH:mm:ss")
                    (nil                                      "MMM d h:mm:ss a")
                    (nil                                      "h:mm:ss a")))
      (push (list (or (car data) (cadr data)) (cons 'java-pattern (cadr data))) formats)
      (when (string-match "\\." (cadr data))
        (nconc (car formats) '((datetime-options :any-decimal-separator t))))
      (when (car data)
        (nconc (car formats) (list (list 'aliases (cadr data))))))
    (nreverse formats))
  "Alist of standard timestamp formats.
This value is used as the fallback for customizable
`logview-additional-timestamp-formats'.")



;;; Customization.

(defgroup logview nil
  "Log viewing mode."
  :group 'text)


(defun logview--set-submode-affecting-variable (variable value)
  (set variable value)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (and (eq major-mode 'logview-mode) (not (logview-initialized-p)))
        (logview--guess-submode)))))

(defvar logview--additional-submodes-type
  (let* ((italicize      (lambda (string) (propertize string 'face 'italic)))
         (mapping-option (lambda (mapping)
                           (let ((name    (car mapping))
                                 (aliases (cdr (assq 'aliases (cdr mapping)))))
                             (list 'const
                                   :tag (if aliases
                                            (format "%s (aka: %s)" (funcall italicize name) (mapconcat italicize aliases ", "))
                                          (funcall italicize name))
                                   name)))))
    (list 'repeat (list 'cons '(string :tag "Name")
                        (list 'list :tag "Definition"
                              '(cons :tag "" (const :tag "Format:" format) string)
                              (list 'set :inline t
                                    (list 'cons :tag "" '(const :tag "Level map:" levels)
                                          (append '(choice)
                                                  (mapcar mapping-option logview-std-level-mappings)
                                                  '((string :tag "Other name"))))
                                    (list 'cons :tag "" '(const :tag "Timestamp:" timestamp)
                                          (list 'choice
                                                '(const :tag "Any supported" nil)
                                                (list 'repeat
                                                      (append '(choice)
                                                              (mapcar mapping-option logview-std-timestamp-formats)
                                                              '((string :tag "Other name"))))))
                                    '(cons :tag "" (const :tag "Aliases:"   aliases)   (repeat string))))))))

(defcustom logview-additional-submodes nil
  "Association list of log submodes (file parsing rules).

A few common submodes are already defined by the mode in variable
`logview-std-submodes', but the ones you add here always take
precedence.

Submode definition has one required and several optional fields:

format

    The only mandatory and the most important field that defines
    how log entries are built from pieces.  There are currently
    four such supported pieces: \"TIMESTAMP\", \"LEVEL\", \"NAME\"
    and \"THREAD\".  All four are optional.  For example, Log4j,
    by default formats entries according to this pattern:

        TIMESTAMP [THREAD] LEVEL NAME -

    Additionally, you can use special placeholder \"IGNORED\" if
    needed.  Usecase for it are log files that contain too many
    fields to map to the ones Logview supports natively.

    Finally, you can explicitly specify \"MESSAGE\" field at the
    very end of the format string.  Normally, you can leave that
    to Logview, just as in the example above.  However, when the
    mode adds the field itself, it also prepends it with a space,
    which might be incorrect for some special custom submodes.

levels  [may be optional]

    Level mapping (see `logview-additional-level-mappings') used
    for this submode.  This field is optional only if the submode
    lacks levels altogether.

    There are some predefined values valid for this field:
    \"SLF4J\" (and its alises \"Log4j\", \"Log4j2\", \"Logback\"
    and \"JUL\".  See variable `logview-std-level-mappings' for
    details.

timestamp  [optional]

    If set, must be a list of timestamp format names to try (see
    `logview-additional-timestamp-formats').  If not set or
    empty, all defined timestamp formats will be tried.

aliases  [optional]

    Submode can have any number of optional aliases, which work just
    as the name."
  :group 'logview
  :type  logview--additional-submodes-type
  :set   'logview--set-submode-affecting-variable
  :set-after '(logview-additional-timestamp-formats logview-additional-level-mappings))

(defcustom logview-additional-level-mappings nil
  "Association list of log level mappings.

A few common maps are already defined by the mode in variable
`logview-std-level-mappings', but the ones you add here always
take precedence.

Each mapping has a name, by which it is referred from submode
definition.  Mapping itself consists of five lists of strings:
error levels, warning levels, information levels, debug levels
and trace levels.  In these lists you should add all possible
real levels that can appear in log file, in descending order of
severity.

For example, for Java SLF4J (Log4j, Logback, etc.) the mapping
looks like this:

        Error levels:        ERROR
        Warning levels:      WARN
        Information levels:  INFO
        Trace levels:        TRACE
        Debug levels:        DEBUG

This is not a coincidence, as the mode is primarily targeted at
SLF4J log files.

However, mapping for JUL (java.util.logging) framework looks more
complicated:

        Error levels:        SEVERE
        Warning levels:      WARNING
        Information levels:  INFO
        Trace levels:        CONFIG, FINE
        Debug levels:        FINER, FINEST

JUL has seven severity levels and we need to map them to five the
mode supports.  So the last two lists contain two levels each.
It is also legal to have empty lists, usually if there are less
than five levels.

Mapping can have any number of optional aliases, which work just
as the name."
  :group 'logview
  :type  '(repeat (cons (string :tag "Name")
                        (list :tag "Definition"
                              (cons :tag "" (const :tag "Error levels:"       error)       (repeat string))
                              (cons :tag "" (const :tag "Warning levels:"     warning)     (repeat string))
                              (cons :tag "" (const :tag "Information levels:" information) (repeat string))
                              (cons :tag "" (const :tag "Debug levels:"       debug)       (repeat string))
                              (cons :tag "" (const :tag "Trace levels:"       trace)       (repeat string))
                              (set :inline t
                                   (cons :tag "" (const :tag "Aliases:" aliases) (repeat string))))))
  :set   'logview--set-submode-affecting-variable)

(defcustom logview-additional-timestamp-formats nil
  "Association list of additional timestamp formats.

A few common formats are already defined by the mode in variable
`logview-std-timestamp-formats', but the ones you add here always
take precedence.

Each format has a name, by which it can be referred from submode
definition.  A format is defined by Java-like pattern.  If the
pattern contains text strings, e.g. month names, you can specify
the locale to use (defaults to English).

See `datetime' library for the help about patterns, or read

    https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html

A more complicated and mostly obsolete way to specify format is
by using regular expression timestamp must match.  It is strongly
recommended to make the expression as strict as possible to avoid
false positives.  For example, if you entered something like
\"\\w+\" as an expression, this would often lead to Logview mode
autoselecting wrong submode and thus parsing log files
incorrectly.  Regular expression is ignored if Java pattern is
also specified.

Timestamp format can have any number of optional aliases, which
work just as the name."
  :group 'logview
  :type  '(repeat (cons (string :tag "Name")
                        (list :tag "Definition"
                              (set :inline t
                                   (cons :tag "" (const :tag "Java pattern:"       java-pattern)     string)
                                   (cons :tag "" (const :tag "Locale:"             locale)           symbol)
                                   (cons :tag "" (const :tag "Datetime options:"   datetime-options) plist)
                                   (cons :tag "" (const :tag "Regular expression:" regexp)           regexp)
                                   (cons :tag "" (const :tag "Aliases:" aliases) (repeat string))))))
  :set   'logview--set-submode-affecting-variable)


(defcustom logview-auto-revert-mode nil
  "Automatically put recognized buffers into Auto-Revert mode.
Buffers for which no appropriate submode can be guessed are not
affected and buffers not associated with files.  Having this set
to \"Off\" doesn't prevent Global Auto-Revert mode from affecting
Logview buffers.

Whenever new text is added to the buffer, it is automatically
parsed, highlighted and all currently active filters are applied
to it.

To temporarily activate or deactivate Auto-Revert (Tail) mode in
a Logview buffer type \\<logview-mode-map>\\[auto-revert-mode] or \\<logview-mode-map>\\[auto-revert-tail-mode]."
  :group 'logview
  :type  '(choice (const :tag "Off"                   nil)
                  (const :tag "Auto-Revert mode"      auto-revert-mode)
                  (const :tag "Auto-Revert Tail mode" auto-revert-tail-mode)))

(defcustom logview-reassurance-chars 5000
  "Compare this many characters before appending file tail.
This value is used by the command `logview-append-log-file-tail'
to compare part of the file on disk with part of the buffer to
make sure (even if not with 100% guarantee) that the buffer
really represents beginning of its backing file.  The command
will refuse to complete operation unless this check succeeds."
  :group 'logview
  :type  'integer)


(defcustom logview-copy-visible-text-only t
  "Whether to copy, kill, etc. only visible selected text.
Standard Emacs behavior is to copy even invisible text, but that
typically doesn't make much sense with filtering.

To temporarily change this on per-buffer basis type \\<logview-mode-map>\\[logview-toggle-copy-visible-text-only]."
  :group 'logview
  :type  'boolean)

(defcustom logview-search-only-in-messages nil
  "Whether to incrementally search only in messages.
Normally search is not restricted and matches can be found
anywhere.  However, it is sometimes useful to ignore other parts
of log entries, e.g. timestamp when searching for numbers.

To temporarily change this on per-buffer basis type \\<logview-mode-map>\\[logview-toggle-search-only-in-messages]."
  :group 'logview
  :type  'boolean)

(defcustom logview-show-ellipses t
  "Whether to show ellipses to indicate hidden log entries.

To temporarily change this on per-buffer basis type \\<logview-mode-map>\\[logview-toggle-show-ellipses]."
  :group 'logview
  :type  'boolean)

(defcustom logview-views-file (locate-user-emacs-file "logview.views")
  "Simple text file in which defined views are stored."
  :group 'logview
  :type  'file)

(defcustom logview-completing-read-function nil
  "Completion system used by Logview."
  :group 'logview
  :type  '(radio
           (const :tag "Auto" nil)
           (function-item completing-read)
           (function-item ido-completing-read)
           (function :tag "Custom function")))


(defgroup logview-faces nil
  "Faces for Logview mode."
  :group 'logview)

(defface logview-level-error
  '((t :inherit error))
  "Face to use for error level strings.")

(defface logview-error-entry
  '((((background dark))
     :background "#600000")
    (t
     :background "#ffe0e0"))
  "Face to use for error log entries."
  :group 'logview-faces)

(defface logview-level-warning
  '((t :inherit warning))
  "Face to use for warning level strings."
  :group 'logview-faces)

(defface logview-warning-entry
  '((((background dark))
     :background "#606000")
    (t
     :background "#ffffe0"))
  "Face to use for warning log entries."
  :group 'logview-faces)

(defface logview-level-information
  '((t :inherit success))
  "Face to use for information level strings."
  :group 'logview-faces)

(defface logview-information-entry
  '((((background dark))
     :background "#004000")
    (t
     :background "#e8ffe8"))
  "Face to use for information log entries."
  :group 'logview-faces)

(defface logview-level-debug
  nil
  "Face to use for debug level strings."
  :group 'logview-faces)

(defface logview-debug-entry
  nil
  "Face to use for debug log entries."
  :group 'logview-faces)

(defface logview-level-trace
  '((t :inherit shadow))
  "Face to use for trace level strings."
  :group 'logview-faces)

(defface logview-trace-entry
  '((((background dark))
     :background "#404040")
    (t
     :background "#f0f0f0"))
  "Face to use for trace log entries."
  :group 'logview-faces)

(defface logview-timestamp
  '((t :inherit font-lock-builtin-face))
  "Face to use for log entry timestamp."
  :group 'logview-faces)

(defface logview-name
  '((t :inherit font-lock-string-face))
  "Face to use for logger name."
  :group 'logview-faces)

(defface logview-thread
  '((t :inherit font-lock-variable-name-face))
  "Face to use for logger thread."
  :group 'logview-faces)

(defface logview-edit-filters-type-prefix
  '((((background dark))
     :background "#604000"
     :weight     bold)
    (t
     :background "#ffe0c0"
     :weight     bold))
  "Face to use for type prefixes in filter editing buffer."
  :group 'logview-faces)



;;; Internal variables and constants.

(defconst logview--timestamp-group 1)
(defconst logview--level-group     2)
(defconst logview--name-group      3)
(defconst logview--thread-group    4)
(defconst logview--ignored-group   5)
(defconst logview--message-group   6)

(defconst logview--final-levels '(error warning information debug trace))

(defconst logview--entry-part-regexp (rx bow (or (group "TIMESTAMP")
                                                 (group "LEVEL")
                                                 (group "NAME")
                                                 (group "THREAD")
                                                 (group "IGNORED")
                                                 (group "MESSAGE"))
                                         eow))
(defconst logview--timestamp-entry-part-regexp (rx bow "TIMESTAMP" eow))

(defvar logview--datetime-options '(:second-fractional-extension t
                                    :only-4-digit-years t
                                    :accept-leading-space t
                                    :require-leading-zeros t
                                    :forbid-unnecessary-zeros t))

(defvar logview--all-timestamp-formats-cache nil)

(defconst logview--valid-text-filter-prefixes '("a+" "a-" "t+" "t-" "m+" "m-"))
(defconst logview--valid-filter-prefixes      (append '("lv" "LV") logview--valid-text-filter-prefixes))


(defvar-local logview--submode-name nil)
(defvar-local logview--entry-regexp nil)
(defvar-local logview--submode-features nil)

(defvar-local logview--submode-level-alist nil
  "Submode levels mapped to final levels.
Levels are ordered least to most important.")

(defvar-local logview--submode-level-data nil
  "An alist of level string to the following vectors:
0: level invisibility symbol (for quick filtering);
1: level invisibility symbol when filtered (for quick filtering).
2: level entry face;
3: level string face;
4: result of `logview--hide-entry-callback' with item 1;
5: result of `logview--show-entry-callback' with item 1.")

(defvar-local logview--min-shown-level        nil)
(defvar-local logview--min-always-shown-level nil)
(defvar-local logview--as-important-levels    nil)
(defvar-local logview--hide-all-details       nil)

(defvar-local logview--current-filter-text "")

;; Currently a list of three items: matching function, inclusion and
;; exclusion regexps.
(defvar-local logview--name-filter    nil)
(defvar-local logview--thread-filter  nil)
(defvar-local logview--message-filter nil)

(defvar logview--empty-filter-id '((nil nil) (nil nil) (nil nil)))
(defvar-local logview--applied-filter-id logview--empty-filter-id)

(defvar logview--submode-name-history     nil)
(defvar logview--timestamp-format-history nil)
(defvar logview--name-regexp-history      nil)
(defvar logview--thread-regexp-history    nil)
(defvar logview--message-regexp-history   nil)

(defvar-local logview--process-buffer-changes nil)

(defvar logview--views             nil)
(defvar logview--views-initialized nil)
(defvar logview--views-need-saving nil)

(defvar logview--view-name-history)

(defvar-local logview--filter-editing-buffer nil)
(defvar logview--view-editing-buffer         nil)


(defvar-local logview-filter-edit--parent-buffer             nil)
(defvar-local logview-filter-edit--window-configuration      nil)
(defvar-local logview-filter-edit--editing-views             nil)
(defvar-local logview-filter-edit--editing-views-for-submode nil)

(defvar logview-filter-edit--filters-hint-comment
  "# Press C-c C-c to save edited filters, C-c C-k to quit without saving.
")

(defvar logview-filter-edit--views-hint-comment
  "# Press C-c C-c to save edited views, C-c C-k to quit without saving.
")

(defconst logview--view-header-regexp  (rx bol (group "view")    " " (group (1+ nonl)) eol))
(defconst logview--view-submode-regexp (rx bol (group "submode") " " (group (1+ nonl)) eol))


(defvar logview--cheat-sheet
  '(("Movement"
     (logview-go-to-message-beginning                                        "Beginning of entry’s message")
     (logview-next-entry                 logview-previous-entry              "Next / previous entry")
     (logview-next-as-important-entry    logview-previous-as-important-entry "Next / previous ‘as important’ entry")
     (logview-first-entry                logview-last-entry                  "First / last entry")
     "‘As important’ means entries with the same or higher level.")
    ("Narrowing and widening"
     (logview-narrow-from-this-entry     logview-narrow-up-to-this-entry     "Narrow from / up to this entry")
     (widen                                                                  "Widen")
     (logview-widen-upwards              logview-widen-downwards             "Widen upwards / downwards"))
    ("Filtering by level"
     (logview-show-only-errors                                               "Show only errors")
     (logview-show-errors-and-warnings                                       "Show errors and warnings")
     (logview-show-errors-warnings-and-information                           "Show errors, warnings and information")
     (logview-show-errors-warnings-information-and-debug                     "Show all levels except trace")
     (logview-show-all-levels                                                "Show entries of all levels")
     (logview-show-only-as-important                                         "Show entries ‘as important’ as the current one"))
    ("Always show entries of certain levels"
     (logview-disable-unconditional-show                                     "Disable ‘always show’")
     (logview-always-show-errors                                             "Always (i.e. regardless of text filters) show errors")
     (logview-always-show-errors-and-warnings                                "Always show errors and warnings")
     (logview-always-show-errors-warnings-and-information                    "Always show errors, warnings and information")
     (logview-always-show-errors-warnings-information-and-debug              "Always show all levels except trace"))
    ("Text-based filtering"
     (logview-edit-filters                                                   "Edit filters as text in a separate buffer")
     (logview-add-include-name-filter    logview-add-exclude-name-filter     "Add name include / exclude filter")
     (logview-add-include-thread-filter  logview-add-exclude-thread-filter   "Add thread include / exclude filter")
     (logview-add-include-message-filter logview-add-exclude-message-filter  "Add message include / exclude filter"))
    ("Resetting filters"
     (logview-reset-level-filters                                            "Reset level filters")
     (logview-reset-name-filters                                             "Reset name filters")
     (logview-reset-thread-filters                                           "Reset thread filters")
     (logview-reset-message-filters                                          "Reset message filters")
     (logview-reset-all-filters                                              "Reset all filters")
     (logview-reset-all-filters-restrictions-and-hidings                     "Reset filters, widen and show explicitly hidden entries"))
    ("Views"
     (logview-switch-to-view                                                 "Switch to a view")
     (logview-save-filters-as-view-for-submode                               "Save the filters as a view for the current submode")
     (logview-save-filters-as-global-view                                    "Save the filters as a globally available view")
     (logview-edit-submode-views                                             "Edit views for the current submode")
     (logview-edit-all-views                                                 "Edit all views")
     (logview-delete-view                                                    "Delete a view"))
    ("Explicitly hide or show entries"
     (logview-hide-entry                                                     "Hide entry")
     (logview-hide-region-entries                                            "Hide entries in the region")
     (logview-show-entries                                                   "Show some explicitly hidden entries")
     (logview-show-region-entries                                            "Show explicitly hidden entries in the region"))
    ("Hide or show details of individual entries"
     (logview-toggle-entry-details                                           "Toggle details of the current entry")
     (logview-toggle-region-entry-details                                    "Toggle details of entries in the region")
     (logview-toggle-details-globally                                        "Toggle details in the whole buffer")
     "Here ‘details’ are the message lines after the first.")
    ("Change options for current buffer"
     (auto-revert-mode                                                       "Toggle Auto-Revert mode")
     (auto-revert-tail-mode                                                  "Toggle Auto-Revert Tail mode")
     (logview-toggle-copy-visible-text-only                                  "Toggle ‘copy only visible text’")
     (logview-toggle-search-only-in-messages                                 "Toggle ‘search only in messages’")
     (logview-toggle-show-ellipses                                           "Toggle ‘show ellipses’")
     "Options can be customized globally or changed in each buffer.")
    ("Miscellaneous"
     (logview-choose-submode                                                 "Manually choose appropriate submode")
     (logview-customize-submode-options                                      "Customize options that affect submode selection")
     (bury-buffer                                                            "Bury buffer")
     (logview-refresh-buffer-as-needed                                       "Append tail or revert the buffer, as needed")
     (logview-append-log-file-tail                                           "Append log file tail to the buffer")
     (logview-revert-buffer                                                  "Revert the buffer preserving active filters")
     "Universal prefix commands are bound without modifiers: \\[universal-argument], \\[negative-argument], \\[digit-argument <0>]..\\[digit-argument <9>].")))



;;; Macros and inlined functions.

;; Lisp is sensitive to declaration order, so these are collected at
;; the beginnig of the file.

(defmacro logview--std-matching (&rest body)
  (declare (indent 0) (debug t))
  `(save-excursion
     (let ((case-fold-search nil))
       ,@body)))

(defmacro logview--std-matching-and-altering (&rest body)
  (declare (indent 0) (debug t))
  `(save-excursion
     (let ((logview--process-buffer-changes nil)
           (case-fold-search                nil)
           (inhibit-read-only               t))
       (with-silent-modifications
         ,@body))))


;; The following (inlined) functions are needed when applying
;; 'invisible' property.  Generally we count entry from start of its
;; line to the start of next entry's line.  This works nice e.g. for
;; highlighting.  However, for hiding entries we need to take linefeed
;; that _preceeds_ the entry, otherwise ellipses show at line
;; beginnings, which is ugly and shifts actual buffer text.

(defsubst logview--linefeed-back-checked (position)
  "Return end of previous line.
This function assumes POSITION is at the beginning of a line.  If
this is the first line, don't change POSITION."
  (if (> position 1)
      (1- position)
    1))

(defsubst logview--linefeed-back (position)
  "Return end of previous line assumin non-first line.
This function assumes POSITION is at the beginning of a line and
that the line is not the first in the buffer."
  (1- position))



;;; The mode.

(defvar logview-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (dolist (binding '(;; Movement commands.
                       ("TAB" logview-go-to-message-beginning)
                       ("n"   logview-next-entry)
                       ("p"   logview-previous-entry)
                       ("N"   logview-next-as-important-entry)
                       ("P"   logview-previous-as-important-entry)
                       ("<"   logview-first-entry)
                       (">"   logview-last-entry)
                       ;; Narrowing/widening commands.
                       ("["   logview-narrow-from-this-entry)
                       ("]"   logview-narrow-up-to-this-entry)
                       ("w"   widen)
                       ("{"   logview-widen-upwards)
                       ("}"   logview-widen-downwards)
                       ;; Filtering by level commands.
                       ("l 1" logview-show-only-errors)
                       ("l e" logview-show-only-errors)
                       ("l 2" logview-show-errors-and-warnings)
                       ("l w" logview-show-errors-and-warnings)
                       ("l 3" logview-show-errors-warnings-and-information)
                       ("l i" logview-show-errors-warnings-and-information)
                       ("l 4" logview-show-errors-warnings-information-and-debug)
                       ("l d" logview-show-errors-warnings-information-and-debug)
                       ("l 5" logview-show-all-levels)
                       ("l t" logview-show-all-levels)
                       ("+"   logview-show-only-as-important)
                       ("l +" logview-show-only-as-important)
                       ("L 1" logview-always-show-errors)
                       ("L e" logview-always-show-errors)
                       ("L 2" logview-always-show-errors-and-warnings)
                       ("L w" logview-always-show-errors-and-warnings)
                       ("L 3" logview-always-show-errors-warnings-and-information)
                       ("L i" logview-always-show-errors-warnings-and-information)
                       ("L 4" logview-always-show-errors-warnings-information-and-debug)
                       ("L d" logview-always-show-errors-warnings-information-and-debug)
                       ("L 0" logview-disable-unconditional-show)
                       ("L L" logview-disable-unconditional-show)
                       ;; Filtering by name/thread/message commands.
                       ("f"   logview-edit-filters)
                       ("a"   logview-add-include-name-filter)
                       ("A"   logview-add-exclude-name-filter)
                       ("t"   logview-add-include-thread-filter)
                       ("T"   logview-add-exclude-thread-filter)
                       ("m"   logview-add-include-message-filter)
                       ("M"   logview-add-exclude-message-filter)
                       ;; Filter resetting commands.
                       ("r l" logview-reset-level-filters)
                       ("r a" logview-reset-name-filters)
                       ("r t" logview-reset-thread-filters)
                       ("r m" logview-reset-message-filters)
                       ("R"   logview-reset-all-filters)
                       ("r e" logview-reset-all-filters-restrictions-and-hidings)
                       ;; View commands.
                       ("v"   logview-switch-to-view)
                       ("V s" logview-save-filters-as-view-for-submode)
                       ("V S" logview-save-filters-as-global-view)
                       ("V e" logview-edit-submode-views)
                       ("V E" logview-edit-all-views)
                       ("V d" logview-delete-view)
                       ;; Explicit entry hiding/showing commands.
                       ("h"   logview-hide-entry)
                       ("H"   logview-hide-region-entries)
                       ("s"   logview-show-entries)
                       ("S"   logview-show-region-entries)
                       ;; Showing/hiding entry details commands.
                       ("d"   logview-toggle-entry-details)
                       ("D"   logview-toggle-region-entry-details)
                       ("e"   logview-toggle-details-globally)
                       ;; Option changing commands.
                       ("o r" auto-revert-mode)
                       ("o t" auto-revert-tail-mode)
                       ("o v" logview-toggle-copy-visible-text-only)
                       ("o m" logview-toggle-search-only-in-messages)
                       ("o e" logview-toggle-show-ellipses)
                       ("o s" logview-choose-submode)
                       ("o S" logview-customize-submode-options)
                       ;; For compatibility with the inactive keymap.
                       ("C-c C-c" logview-choose-submode)
                       ("C-c C-s" logview-customize-submode-options)
                       ;; Miscellaneous commands.
                       ("?"   logview-mode-help)
                       ("g"   logview-refresh-buffer-as-needed)
                       ("x"   logview-append-log-file-tail)
                       ("X"   logview-revert-buffer)
                       ("q"   bury-buffer)
                       ;; Simplified universal argument command
                       ;; rebindings.  Digits and minus are set up by
                       ;; 'suppress-keymap' already.
                       ("u"   universal-argument)))
      (define-key map (kbd (car binding)) (cadr binding)))
    map))

(defvar logview-mode-inactive-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-c") 'logview-choose-submode)
    (define-key map (kbd "C-c C-s") 'logview-customize-submode-options)
    map)
  "Keymap used by `logview-mode' when the mode is inactive.
Mode is inactive when the buffer is not read-only (to not
interfere with editing) or if submode wasn't guessed
successfully.")


;;;###autoload
(define-derived-mode logview-mode nil "Logview"
  "Major mode for viewing and filtering various log files."
  (logview--update-keymap)
  (add-hook 'read-only-mode-hook 'logview--update-keymap nil t)
  (set (make-local-variable 'filter-buffer-substring-function) 'logview--buffer-substring-filter)
  (set (make-local-variable 'isearch-filter-predicate)         'logview--isearch-filter-predicate)
  (add-hook 'change-major-mode-hook 'logview--exiting-mode nil t)
  (logview--guess-submode)
  (logview--update-invisibility-spec)
  (unless (logview-initialized-p)
    (message "Cannot determine log format; press C-c C-c to choose manually or C-c C-s to customize relevant options")))

(defun logview--update-keymap ()
  (use-local-map (if (and buffer-read-only (logview-initialized-p))
                     logview-mode-map
                   logview-mode-inactive-map)))

(defun logview--exiting-mode ()
  ;; Remove custom invisibility property values, as otherwise other
  ;; modes will show empty buffers.  Also remove face property, as we
  ;; set it ourselves, not through font-lock.
  (logview--std-matching-and-altering
    (remove-text-properties 1 (1+ (buffer-size)) '(face nil invisible nil))))

(defun logview-initialized-p ()
  (not (null logview--entry-regexp)))



;;; Movement commands.

(defun logview-go-to-message-beginning (&optional select-message)
  "Put point at the beginning of the current entry's message.

With prefix argument, additionally put mark at the end of the
message, which is especially useful for multiline messages.  In
Transient Mark mode also activate the region."
  (interactive "P")
  (logview--assert)
  (let ((case-fold-search nil))
    (when (logview--match-current-entry)
      (goto-char (match-end 0))
      (when select-message
        (save-excursion
          (push-mark (logview--linefeed-back (if (equal (logview--match-successive-entries 1) 0)
                                                 (match-beginning 0)
                                               (point-max)))
                     t t))))))

(defun logview-next-entry (&optional n)
  "Move point vertically down N (1 by default) log entries.

Point is positioned at the beginning of the message of the
resulting entry.  If log entries are single-line, this is almost
equal to `next-line'.  However, if messages span several lines,
the function will have significantly different effect."
  (interactive "p")
  (logview--assert)
  (when (/= n 0)
    (let ((case-fold-search nil)
          (original-point   (point))
          (remaining        (logview--match-successive-entries n t)))
      (goto-char (if remaining (match-end 0) original-point))
      (logview--maybe-complain-about-movement n remaining))))

(defun logview-previous-entry (&optional n)
  "Move point vertically up N (1 by default) log entries.

Point is positioned at the beginning of the message of the
resulting entry.  If log entries are single-line, this is almost
equal to `next-line'.  However, if messages span several lines,
the function will have significantly different effect."
  (interactive "p")
  (logview-next-entry (if n (- n) -1)))

(defun logview-next-as-important-entry (&optional n)
  "Move point vertically down N 'as important' entries.

Here 'as important' means any entry of level equal or higher than
that of the current entry.  For example, if you start moving from
a warning, the function will stop on all warnings and errors in
the buffer, but skip all other 'less important' entries.  If the
last used command is either `logview-next-as-important-entry' or
`logview-previous-as-important-entry', list of what is considered
'as important' is kept, otherwise it is recomputed anew.

Point is positioned at the beginning of the message of the
resulting entry."
  (interactive "p")
  (logview--assert 'level)
  (when (/= n 0)
    (let ((case-fold-search nil)
          (original-point   (point)))
      (unless (memq last-command '(logview-next-as-important-entry logview-previous-as-important-entry))
        (setq logview--as-important-levels nil)
        (logview--match-current-entry)
        (let ((this-level (match-string logview--level-group))
              (found))
          (dolist (level-pair logview--submode-level-alist)
            (unless found
              (setq found (equal (car level-pair) this-level)))
            (when found
              (push (car level-pair) logview--as-important-levels)))))
      (let ((remaining (logview--match-successive-entries
                        n t (lambda ()
                              (member (match-string logview--level-group) logview--as-important-levels)))))
        (goto-char (if remaining (match-end 0) original-point))
        (logview--maybe-complain-about-movement n remaining t)))))

(defun logview-previous-as-important-entry (&optional n)
  "Move point vertically up N 'as important' entries.

See function `logview-next-as-important-entry' for definition of
'as important'.

Point is positioned at the beginning of the message of the
resulting entry."
  (interactive "p")
  (logview-next-as-important-entry (if n (- n) -1)))

(defun logview-first-entry ()
  "Move point to the first log entry.

Point is positioned at the beginning of the message of the entry.
Otherwise this function is similar to `beginning-of-buffer'."
  (interactive)
  (logview--assert)
  (unless (region-active-p)
    (push-mark))
  (goto-char (point-min))
  (let ((case-fold-search nil))
    (when (logview--match-current-entry)
      (goto-char (match-end 0)))))

(defun logview-last-entry ()
  "Move point to the last log entry.

Point is positioned at the beginning of the message of the entry.
If the last entry is multiline, this makes the function quite
different from `end-of-buffer'."
  (interactive)
  (logview--assert)
  (unless (region-active-p)
    (push-mark))
  (goto-char (point-max))
  (let ((case-fold-search nil))
    (when (logview--match-current-entry)
      (goto-char (match-end 0)))))



;;; Narrowing/widening commands.

(defun logview-narrow-from-this-entry (&optional n)
  "Narrow the buffer so that previous log entries are hidden.

If invoked interactively with a prefix argument, leave that many
entries above the current visible after narrowing.  Note that as
an exception to standard numeric prefix value rules, here no
prefix means zero."
  (interactive (list (when current-prefix-arg
                       (prefix-numeric-value current-prefix-arg))))
  (logview--do-narrow-one-side t n))

(defun logview-narrow-up-to-this-entry (&optional n)
  "Narrow the buffer so that following log entries are hidden.

If invoked interactively with a prefix argument, leave that many
entries under the current visible after narrowing.  Note that as
an exception to standard numeric prefix value rules, here no
prefix means zero."
  (interactive (list (when current-prefix-arg
                       (prefix-numeric-value current-prefix-arg))))
  (logview--do-narrow-one-side nil n))

(defun logview--do-narrow-one-side (upwards n)
  (logview--assert)
  (let ((from (point-min))
        (to   (point-max)))
    (widen)
    (logview--std-matching
      (narrow-to-region (if (and upwards (equal (logview--match-successive-entries (if n (- n) 0) t) 0))
                            (match-beginning 0)
                          from)
                        (if (and (not upwards) (equal (logview--match-successive-entries (if n (1+ n) 1) t) 0))
                            (match-beginning 0)
                          to)))))

(defun logview-widen-upwards ()
  "Widen the buffer only upwards, i.e. keep the bottom restriction."
  (interactive)
  (let ((to (point-max)))
    (widen)
    (narrow-to-region (point-min) to)))

(defun logview-widen-downwards ()
  "Widen the buffer only downwards, i.e. keep the top restriction."
  (interactive)
  (let ((from (point-min)))
    (widen)
    (narrow-to-region from (point-max))))



;;; Filtering by level commands.

(defun logview-show-only-errors ()
  "Show only error entries."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'error)))

(defun logview-show-errors-and-warnings ()
  "Show only error and warning entries."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'warning)))

(defun logview-show-errors-warnings-and-information ()
  "Show error, warning and information entries."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'information)))

(defun logview-show-errors-warnings-information-and-debug ()
  "Show error, warning, information and debug entries.
I.e. all entries other than traces."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'debug)))

(defun logview-show-all-levels ()
  "Show entries of all levels.
This doesn't cancel other filters that might be in effect
though."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'trace)))

(defun logview-show-only-as-important ()
  "Show entries 'as important' as the current.

Here 'as important' means any entry of level equal or higher.
For example, if you invoke this function while current entry is a
warning, all entries other than warnings and errors will be
hidden."
  (interactive)
  (logview--assert 'level)
  (logview--std-matching
    (when (logview--match-current-entry)
      (logview--change-min-level-filter (match-string logview--level-group)))))

(defun logview-always-show-errors ()
  "Always show error entries."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'error) t))

(defun logview-always-show-errors-and-warnings ()
  "Always show error and warning entries."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'warning) t))

(defun logview-always-show-errors-warnings-and-information ()
  "Always show error, warning and information entries."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'information) t))

(defun logview-always-show-errors-warnings-information-and-debug ()
  "Always show error, warning, information and debug entries.
I.e. all entries other than traces are shown with no regard to
text filters."
  (interactive)
  (logview--change-min-level-filter (logview--find-min-level 'debug) t))

(defun logview-disable-unconditional-show ()
  "Disable unconditional display of entries.
All entries, regardless of level, will be shown only if they
match the current text filters."
  (interactive)
  (logview--change-min-level-filter nil t))

(defun logview--find-min-level (final-level)
  "Find minimal submode level that maps to given FINAL-LEVEL or higher."
  (logview--assert 'level)
  (let ((result)
        (final-level-index (cl-position final-level logview--final-levels)))
    (dolist (level-pair logview--submode-level-alist)
      (when (and (null result) (<= (cl-position (cdr level-pair) logview--final-levels :test 'equal) final-level-index))
        (setq result (car level-pair))))
    result))

(defun logview--change-min-level-filter (min-level &optional always-show)
  (when (and min-level (string= min-level (caar logview--submode-level-alist)))
    (setq min-level nil))
  (let ((case-fold-search nil)
        (filter-prefix    (if always-show "LV" "lv")))
    (let* ((level-filter-at       (string-match (format "^%s .*$" filter-prefix) logview--current-filter-text))
           (level-filter-line-end (match-end 0)))
      (if level-filter-at
          (setq logview--current-filter-text
                (concat (substring logview--current-filter-text 0 level-filter-at)
                        (substring logview--current-filter-text
                                   (or (string-match "^" logview--current-filter-text level-filter-line-end)
                                       level-filter-line-end))))
        (setq level-filter-at 0))
      (when min-level
        (setq logview--current-filter-text (concat (substring logview--current-filter-text 0 level-filter-at)
                                                   filter-prefix " " min-level "\n"
                                                   (substring logview--current-filter-text level-filter-at))))))
  (logview--parse-filters))

(defun logview--set-min-level (min-level min-always-shown-level)
  (unless (and (equal logview--min-shown-level min-level) (equal logview--min-always-shown-level min-always-shown-level))
    (setq logview--min-shown-level        min-level
          logview--min-always-shown-level min-always-shown-level)
    (logview--update-invisibility-spec)))



;;; Filtering by name/thread commands.

(defun logview-edit-filters ()
  "Edit the current filters in a separate buffer."
  (interactive)
  (let ((self    (current-buffer))
        (windows (current-window-configuration))
        (filters logview--current-filter-text))
    (unless (buffer-live-p logview--filter-editing-buffer)
      (setq logview--filter-editing-buffer (generate-new-buffer (format "%s: Filters" (buffer-name)))))
    (split-window-vertically)
    (other-window 1)
    (switch-to-buffer logview--filter-editing-buffer)
    (unless (eq major-mode 'logview-filter-edit-mode)
      (logview-filter-edit-mode))
    (setq logview-filter-edit--parent-buffer        self
          logview-filter-edit--window-configuration windows
          logview-filter-edit--editing-views        nil)
    (logview-filter-edit--initialize-text filters)))

(defun logview-add-include-name-filter ()
  "Show only entries with name matching regular expression.
If this command is invoked multiple times, show entries with name
matching at least one of entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Logger name regexp to show entries" 'name "a+"))

(defun logview-add-exclude-name-filter ()
  "Hide entries with name matching entered regular expression.
If this command is invoked multiple times, filter out them all,
i.e. show only entries with name that doesn't match any of
entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Logger name regexp to hide entries" 'name "a-"))

(defun logview-add-include-thread-filter ()
  "Show only entries with thread matching regular expression.
If this command is invoked multiple times, show entries with
thread name matching at least one of entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Thread regexp to show entries" 'thread "t+"))

(defun logview-add-exclude-thread-filter ()
  "Hide entries with thread matching entered regular expression.
If this command is invoked multiple times, filter out them all,
i.e. show only entries with thread name that doesn't match any of
entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Thread regexp to hide entries" 'thread "t-"))

(defun logview-add-include-message-filter ()
  "Show only entries with message matching regular expression.
Expression may be multiline.  If this command is invoked multiple
times, show entries with message matching at least one of entered
expression."
  (interactive)
  (logview--prompt-for-new-filter "Message regexp to show entries" 'message "m+"))

(defun logview-add-exclude-message-filter ()
  "Hide entries with message matching entered regular expression.
Expression may be multiline.  If this command is invoked multiple
times, filter out them all, i.e. show only entries with message
that doesn't match any of entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Message regexp to hide entries" 'message "m-"))

(defun logview--prompt-for-new-filter (prompt type filter-line-prefix)
  (logview--assert type)
  (let* ((default-value (unless (eq type 'message)
                          (logview--std-matching
                            (when (logview--match-current-entry)
                              (let ((base (regexp-quote (match-string (cdr (assq type (list (cons 'name   logview--name-group)
                                                                                            (cons 'thread logview--thread-group))))))))
                                (list base (format "^%s$" base)))))))
         (regexp        (read-regexp prompt default-value (cdr (assq type '((name    . logview--name-regexp-history)
                                                                            (thread  . logview--thread-regexp-history)
                                                                            (message . logview--message-regexp-history)))))))
    (unless (logview--valid-regexp-p regexp)
      (user-error "Invalid regular expression"))
    (when (and (memq type '(name thread)) (string-match "\n" regexp))
      (user-error "Regular expression must not span several lines"))
    (setq logview--current-filter-text (concat logview--current-filter-text
                                               (when (and logview--current-filter-text
                                                          (not (string-suffix-p "\n" logview--current-filter-text)))
                                                 "\n")
                                               filter-line-prefix " " (replace-regexp-in-string "\n" "\n.. " regexp) "\n"))
    (logview--parse-filters)
    (logview--apply-parsed-filters)))

;; This must have been a standard function.
(defun logview--valid-regexp-p (regexp)
  (ignore-errors
    (string-match regexp "")
    t))



;;; Filters resetting commands.

(defun logview-reset-level-filters ()
  "Reset all level filters.
This includes both minimal level to show entries and minimal
level to show entries regardless of text filters."
  (interactive)
  (logview--assert 'level)
  (logview-show-all-levels)
  (logview-disable-unconditional-show))

(defun logview-reset-name-filters ()
  "Reset all name filters."
  (interactive)
  (logview--assert 'name)
  (logview--parse-filters '("a+" "a-"))
  (logview--apply-parsed-filters))

(defun logview-reset-thread-filters ()
  "Reset all thread filters."
  (interactive)
  (logview--assert 'thread)
  (logview--parse-filters '("t+" "t-"))
  (logview--apply-parsed-filters))

(defun logview-reset-message-filters ()
  "Reset all message filters."
  (interactive)
  (logview--assert)
  (logview--parse-filters '("m+" "m-"))
  (logview--apply-parsed-filters))

(defun logview-reset-all-filters ()
  "Reset all filters (level, name, thread).
After this command only explictly hidden entries and entries
outside narrowing buffer restrictions remain invisible."
  (interactive)
  (logview--do-reset-all-filters nil nil))

(defun logview-reset-all-filters-restrictions-and-hidings ()
  "Reset all visibility restrictions.
In other words, reset all filters, show all explictly hidden
entries and cancel any narrowing restrictions."
  (interactive)
  (widen)
  (logview--do-reset-all-filters t t))

(defun logview--do-reset-all-filters (also-show-details also-cancel-explicit-hiding)
  (logview--assert)
  (when also-show-details
    (setq logview--hide-all-details nil))
  (if (memq 'level logview--submode-features)
      (logview-reset-level-filters)
    (when also-show-details
      (logview--update-invisibility-spec)))
  (when (or (memq 'name logview--submode-features) (memq 'thread logview--submode-features) also-cancel-explicit-hiding)
    (logview--parse-filters logview--valid-text-filter-prefixes)
    (logview--apply-parsed-filters also-cancel-explicit-hiding)))



;;; View commands.

(defun logview-switch-to-view (view)
  "Switch to a previously defined view.
Interactively, read the view name from the minibuffer."
  (interactive (logview--choose-view "Switch to view: "))
  (setq logview--current-filter-text (plist-get view :filters))
  (logview--parse-filters)
  (logview--apply-parsed-filters))

(defun logview-save-filters-as-view-for-submode (name)
  "Save the current filter set as a view for the current submode.
Interactively, read the name for the new view from the
minibuffer."
  (interactive (list nil))
  (logview--do-save-filters-as-view name nil))

(defun logview-save-filters-as-global-view (name)
  "Save the current filter set as a global view.
Interactively, read the name for the new view from the
minibuffer."
  (interactive (list nil))
  (logview--do-save-filters-as-view name t))

(defun logview-edit-submode-views ()
  "Edit views for the current submode in a separate buffer."
  (interactive)
  (logview--do-edit-views t))

(defun logview-edit-all-views ()
  "Edit all views in a separate buffer."
  (interactive)
  (logview--do-edit-views nil))

(defun logview-delete-view (view)
  "Delete a view definition.
Interactively, read the view name from the minibuffer."
  (interactive (logview--choose-view "Delete view: "))
  (setq logview--views             (delq view (logview--views))
        logview--views-need-saving t)
  (logview--update-mode-name))

(defun logview--choose-view (prompt)
  (let (defined-names)
    (dolist (view (logview--views))
      (when (or (null (plist-get view :submode)) (string= (plist-get view :submode) logview--submode-name))
        (push (plist-get view :name) defined-names)))
    (unless defined-names
      (user-error "There are no views defined for the current submode"))
    (let ((name      (logview--completing-read prompt defined-names nil t nil 'logview--view-name-history))
          (all-views (logview--views))
          view)
      (while all-views
        (let ((candidate (pop all-views)))
          (when (and (string= (plist-get candidate :name) name)
                     (or (null (plist-get candidate :submode)) (string= (plist-get candidate :submode) logview--submode-name)))
            (setq view      candidate
                  all-views nil))))
      (list view))))

(defun logview--do-save-filters-as-view (name global)
  (unless (or logview--min-shown-level (car logview--name-filter) (car logview--thread-filter) (car logview--message-filter))
    (user-error "There are currently no filters"))
  (unless name
    (setq name (read-string "Name: " nil 'logview--view-name-history)))
  (when (= (length name) 0)
    (user-error "View name may not be empty"))
  (let ((matches (lambda (view)
                   (and (string= (plist-get view :name) name)
                        (or global (null (plist-get view :submode)) (string= (plist-get view :submode) logview--submode-name))))))
    (dolist (view (logview--views))
      (when (funcall matches view)
        (unless (y-or-n-p (format-message (if global
                                              "There is already a view named `%s'. Replace it?"
                                            "There is already a view named `%s' for this submode. Replace it?")
                                          name))
          (user-error "View named `%s' already exists; try a different name" name))))
    (let (new-views)
      (dolist (view (logview--views))
        (unless (funcall matches view)
          (push view new-views)))
      (push (list :name name :filters logview--current-filter-text) new-views)
      (unless global
        (plist-put (car new-views) :submode logview--submode-name))
      (setq logview--views             (nreverse new-views)
            logview--views-need-saving t)
      (logview--update-mode-name)
      (message (if global "Saved filters as a global view named `%s'" "Saved filters as a submode view named `%s'") name))))

(defun logview--do-edit-views (submode-only)
  (let ((self    (current-buffer))
        (windows (current-window-configuration))
        (submode (when submode-only logview--submode-name)))
    (if (buffer-live-p logview--view-editing-buffer)
        (when (and (buffer-modified-p logview--view-editing-buffer)
                   (not (eq (with-current-buffer logview--view-editing-buffer
                              logview-filter-edit--editing-views-for-submode)
                            submode)))
          (pop-to-buffer logview--view-editing-buffer)
          (unless (yes-or-no-p "Discard current view editing changes?")
            (user-error "Another view editing is in progress")))
      (setq logview--view-editing-buffer (generate-new-buffer "Logview views")))
    (split-window-vertically)
    (other-window 1)
    (switch-to-buffer logview--view-editing-buffer)
    (unless (eq major-mode 'logview-filter-edit-mode)
      (logview-filter-edit-mode))
    (setq logview-filter-edit--parent-buffer             self
          logview-filter-edit--window-configuration      windows
          logview-filter-edit--editing-views             t
          logview-filter-edit--editing-views-for-submode submode)
    (logview-filter-edit--initialize-text)))



;;; Explicit entry hiding/showing commands.

(defun logview-hide-entry (&optional n)
  "Explicitly hide N currently visible entries starting at point.
If N is negative, hide -N previous entries instead, not including
the current.

In Transient Mark mode, if the region is active and this command
is invoked without prefix argument, hide all entries in the
region instead (i.e. just like `logview-hide-region-entries')."
  (interactive (list (if (or current-prefix-arg (not (use-region-p)))
                         (prefix-numeric-value current-prefix-arg)
                       'use-region)))
  (if (eq n 'use-region)
      (logview-hide-region-entries (point) (mark))
    (logview--assert)
    (logview--std-matching-and-altering
      (logview--maybe-complain-about-movement
       n (logview--iterate-successive-entries n (logview--hide-entry-callback 'logview-hidden-entry) t) 0))))

(defun logview-hide-region-entries (begin end)
  "Explicitly hide all log entries in the region.
Entries that are in the region only partially are hidden as well.

Note that this includes entries that are currently hidden due to
filtering too.  If you later cancel filtering, all entries in the
region will remain hidden until you also cancel the explicit
hiding."
  (interactive "r")
  (logview--assert)
  (logview--std-matching-and-altering
    (logview--iterate-entries-in-region begin end (logview--hide-entry-callback 'logview-hidden-entry))))

(defun logview-show-entries (&optional n)
  "Show explicitly hidden entries.
By default, explicitly hidden entries between the current and the
next visible are shown.  If invoked with prefix argument, entries
between the current entry and N'th after it (or before it if N is
negative) are shown.

In Transient Mark mode, if the region is active and this command
is invoked without prefix argument, show explicitly hidden
entries in the region instead (i.e. work just like
`logview-show-region-entries')."
  (interactive (list (if (or current-prefix-arg (not (use-region-p)))
                         (prefix-numeric-value current-prefix-arg)
                       'use-region)))
  (if (eq n 'use-region)
      (logview-show-region-entries (point) (mark))
    (logview--assert)
    ;; Much like 'logview--iterate-successive-entries', but because of
    ;; peculiar semantics, not broken out into its own function.
    (when (/= n 0)
      (logview--std-matching-and-altering
        (let ((direction (cl-signum n))
              (shower    (logview--show-entry-callback 'logview-hidden-entry)))
          (funcall (if (< n 0)
                       'logview--iterate-entries-backward
                     ;; To "not count" the current entry.
                     (setq n (1+ n))
                     'logview--iterate-entries-forward)
                   (lambda (begin after-first-line entry-end)
                     (if (invisible-p begin)
                         (progn
                           (funcall shower begin after-first-line entry-end)
                           t)
                       (/= (setq n (- n direction)) 0)))))))
    (logview--maybe-complain-about-movement n n)))

(defun logview-show-region-entries (begin end)
  "Explicitly show all log entries in the region.

Note that entries that are currently hidden due to filtering are
also marked as 'not explicitly hidden'.  However, you will see
any effect only once you clear or alter the responsible filters."
  (interactive "r")
  (logview--assert)
  (logview--std-matching-and-altering
    (logview--iterate-entries-in-region begin end (logview--show-entry-callback 'logview-hidden-entry))))



;;; Showing/hiding entry details commands.

(defun logview-toggle-entry-details (&optional arg)
  "Toggle whether details for current entry are shown.
If invoked with prefix argument, show them if the argument is
positive, hide otherwise.

In Transient Mark mode, if the region is active, call
`logview-toggle-region-entry-details'.  See that function help
for how toggling works."
  (interactive (list (if (use-region-p)
                         (list (or current-prefix-arg 'toggle))
                       (or current-prefix-arg 'toggle))))
  (if (consp arg)
      (logview-toggle-region-entry-details (point) (mark) (car arg))
    (save-excursion
      (save-restriction
        (widen)
        (logview--std-matching-and-altering
          (when (logview--match-current-entry)
            (forward-line)
            (let ((after-first-line (point))
                  (end              (progn (backward-char)
                                           (if (logview--match-successive-entries 1)
                                               (match-beginning 0)
                                             (point-max)))))
              (if (<= end after-first-line)
                  (user-error "Current entry has no details")
                (logview--change-entry-details-visibility after-first-line end
                                                          (if (eq arg 'toggle)
                                                              (memq 'logview-hidden-details
                                                                    (get-text-property (logview--linefeed-back after-first-line) 'invisible))
                                                            (> (prefix-numeric-value arg) 0)))))))))))

(defun logview-toggle-region-entry-details (begin end &optional arg)
  "Toggle whether details in the region are shown.
Toggling works like this: if at least one entry in the region has
details that are visible, all are hidden.  Otherwise, if all are
already hidden, they are shown.  If invoked with prefix argument,
show details if the argument is positive, hide otherwise.

Entries that are in the region only partially are operated on as
well."
  (interactive (list (point) (mark) (or current-prefix-arg 'toggle)))
  (save-excursion
    (save-restriction
      (widen)
      (logview--std-matching-and-altering
        (when (eq arg 'toggle)
          (setq arg 1)
          (logview--iterate-entries-in-region begin end (lambda (_begin after-first-line end)
                                                          (if (or (>= after-first-line end)
                                                                  (memq 'logview-hidden-details (get-text-property after-first-line 'invisible)))
                                                              t
                                                            (setq arg 0)
                                                            nil))))
        (let ((show (> (prefix-numeric-value arg) 0)))
          (logview--iterate-entries-in-region begin end (lambda (_begin after-first-line end)
                                                          (logview--change-entry-details-visibility after-first-line end show)
                                                          t)))))))

(defun logview--change-entry-details-visibility (after-first-line end show)
  (let* ((current-invisible (get-text-property (logview--linefeed-back after-first-line) 'invisible))
         (new-invisible     current-invisible))
    (if show
        (setq new-invisible (remq 'logview-hidden-details new-invisible))
      (unless (memq 'logview-hidden-details new-invisible)
        (push 'logview-hidden-details new-invisible)))
    (unless (eq new-invisible current-invisible)
      (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end) 'invisible new-invisible))))


(defun logview-toggle-details-globally (&optional arg)
  "Toggle whether details are shown in the whole buffer.
If invoked with prefix argument, show details if the argument is
positive, hide otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview--hide-all-details arg (called-interactively-p 'interactive)
                                  "All entry messages details are now hidden"
                                  "Details of entry messages are now visible unless hidden explicitly")
  (logview--update-invisibility-spec))



;;; Option changing commands.

(defun logview-toggle-copy-visible-text-only (&optional arg)
  "Toggle `logview-copy-visible-text-only' just for this buffer.
If invoked with prefix argument, enable the option if the
argument is positive, disable it otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview-copy-visible-text-only arg (called-interactively-p 'interactive)
                                  "Will copy only visible text now"
                                  "Copying commands will behave as in the rest of Emacs"))

(defun logview-toggle-search-only-in-messages (&optional arg)
  "Toggle `logview-search-only-in-messages' just for this buffer.
If invoked with prefix argument, enable the option if the
argument is positive, disable it otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview-search-only-in-messages arg (called-interactively-p 'interactive)
                                  "Incremental search will find matches only in messages"
                                  "Incremental search will behave normally"))

(defun logview-toggle-show-ellipses (&optional arg)
  "Toggle `logview-show-ellipses' just for this buffer.
If invoked with prefix argument, enable the option if the
argument is positive, disable it otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview-show-ellipses arg (called-interactively-p 'interactive)
                                  "Showing ellipses to indicate hidden log entries"
                                  "Hidden log entries are completely invisible")
  (logview--update-invisibility-spec))

(defun logview-choose-submode (submode &optional timestamp)
  "Manually choose submode for the current buffer.
SUBMODE must be a name or an alias a supported submode from
`logview-additional-submodes' or `logview-std-submodes' (aliases
are understood too).  Timestamp may be either such a name or
alias from `logview-additional-timestamp-formats' or
`logview-std-timestamp-formats', or just a raw Java pattern.  If
submode doesn't use timestamps, this parameter is ignored.

When called interactively, both parameters are read in the
minibuffer."
  (interactive (list (let (submodes)
                       (logview--iterate-split-alists (lambda (name definition)
                                                        (push name submodes)
                                                        (setq submodes (append (cdr (assq 'aliases definition)) submodes)))
                                                      logview-additional-submodes logview-std-submodes)
                       (logview--completing-read "Submode name: " submodes nil t nil 'logview--submode-name-history))))
  (let ((submode-definition (logview--get-split-alists submode "submode" logview-additional-submodes logview-std-submodes))
        timestamp-definition)
    (when (string-match logview--timestamp-entry-part-regexp (cdr (assq 'format submode-definition)))
      (unless timestamp
        (unless (called-interactively-p 'interactive)
          (error "Must specify a timestamp format for submode `%s'" submode))
        (setq timestamp (let (timestamps)
                          (logview--iterate-split-alists (lambda (name definition)
                                                           (push name timestamps)
                                                           (setq timestamps (append (cdr (assq 'aliases definition)) timestamps)))
                                                         logview-additional-timestamp-formats logview-std-timestamp-formats)
                          (dolist (format (logview--all-timestamp-formats))
                            (unless (datetime-pattern-locale-dependent-p 'java (car format))
                              (push (car format) timestamps)))
                          (logview--completing-read "Timestamp format: " timestamps nil nil nil 'logview--timestamp-format-history))))
      (setq timestamp-definition (or (logview--get-split-alists timestamp nil logview-additional-timestamp-formats logview-std-timestamp-formats)
                                     ;; Unlike with submodes, allow unrecognized timestamps.
                                     `(,timestamp (java-pattern . ,timestamp)))))
    (catch 'success
      (logview--initialize-submode submode submode-definition (list timestamp-definition))
      ;; This must not happen.
      (error "Internal error initializing submode `%s'" submode))))

(defun logview-customize-submode-options ()
  "Customize all options that affect submode selection.
These are:
* `logview-additional-submodes'
* `logview-additional-level-mappings'
* `logview-additional-timestamp-formats'"
  (interactive)
  ;; Existing entry point only customizes single option, we need three
  ;; at once (but this hardly warrants a separate group).
  (custom-buffer-create-other-window '((logview-additional-submodes          custom-variable)
                                       (logview-additional-level-mappings    custom-variable)
                                       (logview-additional-timestamp-formats custom-variable))
                                     "*Customize Logview Submodes*"))

(defun logview--toggle-option-locally (variable arg &optional show-message message-if-true message-if-false)
  (set (make-local-variable variable)
       (if (eq arg 'toggle)
           (not (symbol-value variable))
         (> (prefix-numeric-value arg) 0)))
  (when show-message
    (message (if (symbol-value variable) message-if-true message-if-false))))



;;; Miscellaneous commands.

(defun logview-mode-help ()
  (interactive)
  ;; Just reinitialize the buffer every time to simplify development.
  (with-current-buffer (get-buffer-create "*Logview cheat sheet*")
    (let ((inhibit-read-only t))
      (with-silent-modifications
        (widen)
        (delete-region 1 (1+ (buffer-size)))
        (let ((keys-width 0))
          (dolist (section logview--cheat-sheet)
            (dolist (entry (cdr section))
              ;; Second argument is a hack to prefer 'l 1' to 'l e' and similar.
              (setq keys-width (max keys-width (length (logview--help-format-keys entry "[1-5]"))))))
          (dolist (section logview--cheat-sheet)
            (unless (bobp)
              (insert "\n"))
            (insert (propertize (car section) 'face (if (display-graphic-p) 'bold 'font-lock-keyword-face)) "\n")
            (dolist (entry (cdr section))
              (if (listp entry)
                  (insert "  " (logview--help-format-keys entry "[1-5]" keys-width)
                          "  " (car (last entry)) "\n")
                (insert "\n  " (replace-regexp-in-string (rx "\\["
                                                             (group (1+ (any alnum ?-)))
                                                             (? " <" (group (1+ (not (any ?>)))) ">")
                                                             "]")
                                                         (lambda (text)
                                                           (save-match-data
                                                             (logview--help-format-keys (list (intern (match-string 1 text))) (match-string 2 text))))
                                                         entry t t)
                        "\n")))))))
    (goto-char 1)
    (help-mode)
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map help-mode-map)
      (substitute-key-definition 'revert-buffer 'undefined map help-mode-map)
      (use-local-map map)))
    (pop-to-buffer "*Logview cheat sheet*"))

(defun logview--help-format-keys (entry &optional preferred-keys width)
  (if (listp entry)
      (let ((strings))
        (dolist (symbol entry)
          (when (symbolp symbol)
            (let ((best-length most-positive-fixnum)
                  (matched-preferred-keys)
                  (keys))
              (dolist (alternative (where-is-internal symbol logview-mode-map))
                (setq alternative            (key-description alternative)
                      matches-preferred-keys (when preferred-keys (string-match preferred-keys alternative)))
                (when (or (< (length alternative) best-length)
                          (and (= (length alternative) best-length)
                               matches-preferred-keys
                               (not matched-preferred-keys)))
                  (setq keys        alternative
                        best-length (length keys))))
              (push (if keys (propertize keys 'face 'font-lock-builtin-face) "") strings))))
        (let ((string (mapconcat 'identity (nreverse strings) " / ")))
          (if width
              (format (format "%%%ds" width) string)
            string)))
    ""))

(defun logview-refresh-buffer-as-needed ()
  "Append log file tail or else revert the whole buffer.
This is conceptually the same as typing \\<logview-mode-map>\\[logview-append-log-file-tail], followed by \\<logview-mode-map>\\[logview-revert-buffer] if the
first command fails.

This command is faster than reloading the whole buffer in the
common case when the log file grows by appending.  Unlike
`logview-append-log-file-tail', it works in all cases, falling
back to full revert if the file appears to have changed in a
different way.

In all cases the current filters are preserved."
  (interactive)
  (unless (and (not (buffer-modified-p)) (logview--do-append-log-file-tail t))
    (logview-revert-buffer)))

(defun logview-append-log-file-tail ()
  "Load log file tail into the buffer preserving active filters.
This command won't ask for confirmation, but cannot be used if
the buffer is modified.

Before loading the tail it verifies that preceding contents
matches that of the buffer.  The command does that by comparing
`logview-reassurance-chars' immediately before the tail with the
end of the buffer. This is of course not fool-proof, but for log
files almost always good enough, especially if they contain
timestamps.

This can be seen as an alternative to `auto-revert-tail-mode':
instead of automatic reverting you ask for it explicitly.  It
should be as simple as typing \\<logview-mode-map>\\[logview-append-log-file-tail], as no confirmations are asked."
  (interactive)
  (when (buffer-modified-p)
    (user-error "Cannot append file tail to a modified buffer"))
  (logview--do-append-log-file-tail))

(defun logview-revert-buffer ()
  "Revert the buffer preserving active filters.
This command won't ask for confirmation unless the buffer is
modified.

This can be seen as an alternative to `auto-revert-mode': instead
of automatic reverting you ask for it explicitly.  It should be
as simple as typing \\<logview-mode-map>\\[logview-revert-buffer], as no confirmations are asked."
  (interactive)
  (let ((revert-without-query (when buffer-file-name (list (regexp-quote buffer-file-name))))
        (was-read-only        buffer-read-only))
    (revert-buffer nil nil t)
    ;; Apparently 'revert-buffer' resets this.
    (read-only-mode (if was-read-only 1 0)))
  ;; If reverting fails we just won't even get here.
  (message "Reverted the buffer"))

(defun logview--do-append-log-file-tail (&optional no-errors)
  "Perform the work of `logview-append-log-file-tail'.
If NO-ERRORS is non-nil and the file has changed in a non-growing
way, returns nil rather than barking.  In case of success, always
returns non-nil."
  (let* ((buffer             (current-buffer))
         (file               buffer-file-name)
         (size               (1+ (buffer-size)))
         (reassurance-chars  (min (max logview-reassurance-chars 0) (1- size)))
         (compare-from       (- size reassurance-chars))
         ;; 'position-bytes' appears to count from 1, yet we need
         ;; zero-based offset.
         (compare-from-bytes (1- (position-bytes compare-from))))
    (with-temp-buffer
      (insert-file-contents file nil compare-from-bytes nil)
      (let ((temporary      (current-buffer))
            (temporary-size (buffer-size)))
        (if (and (>= temporary-size reassurance-chars)
                     (string= (buffer-substring-no-properties 1 (1+ reassurance-chars))
                              (with-current-buffer buffer
                                (save-restriction
                                  (widen)
                                  (buffer-substring-no-properties compare-from size)))))
            (if (= temporary-size reassurance-chars)
                (message "Backing file %s hasn't grown" file)
              (with-current-buffer buffer
                (let ((was-modified      (buffer-modified-p))
                      (inhibit-read-only t)
                      ;; This is to avoid unnecessary confirmation about
                      ;; modifying a buffer with externally changed file.
                      (buffer-file-name  nil))
                  (save-restriction
                    (widen)
                    (save-excursion
                      (goto-char (point-max))
                      (insert-buffer-substring-no-properties temporary (1+ reassurance-chars) (1+ temporary-size))))
                  (restore-buffer-modified-p was-modified))
                (message "Appended the tail of file %s" file)))
          (unless no-errors
            (user-error "Buffer contents doesn't match the head of %s anymore" file)))))))



;;; Internal functions (except helpers for specific command groups).

(defun logview--guess-submode ()
  (save-excursion
    (save-restriction
      (widen)
      (goto-char 1)
      (end-of-line)
      (let ((first-line (buffer-substring 1 (point)))
            standard-timestamps)
        (logview--iterate-split-alists (lambda (_timestamp-name timestamp) (push timestamp standard-timestamps))
                                       logview-additional-timestamp-formats logview-std-timestamp-formats)
        (dolist (format (logview--all-timestamp-formats))
          (push (cdr format) standard-timestamps))
        (setq standard-timestamps (nreverse standard-timestamps))
        (catch 'success
          (logview--iterate-split-alists (lambda (name definition)
                                           (condition-case error
                                               (logview--initialize-submode name definition standard-timestamps first-line)
                                             (error (warn (error-message-string error)))))
                                         logview-additional-submodes logview-std-submodes))))))

(defun logview--initialize-submode (name definition standard-timestamps &optional test-line)
  (let* ((format            (cdr (assq 'format    definition)))
         (timestamp-names   (when test-line (cdr (assq 'timestamp definition))))
         (timestamp-options (if timestamp-names
                                (mapcar (lambda (name)
                                          (logview--get-split-alists name "timestamp format"
                                                                     logview-additional-timestamp-formats logview-std-timestamp-formats))
                                        timestamp-names)
                              standard-timestamps))
         (search-from       0)
         (parts             (list "^"))
         next
         end
         starter terminator
         levels
         timestamp-at
         cannot-match
         features
         have-explicit-message
         (add-text-part (lambda (from to)
                          (push (replace-regexp-in-string "[ \t]+" "[ \t]+" (regexp-quote (substring format from to))) parts))))
    (unless (and (stringp format) (> (length format) 0))
      (user-error "Invalid submode '%s': no format string" name))
    (while (setq next (string-match logview--entry-part-regexp format search-from))
      (when (> next search-from)
        (funcall add-text-part search-from next))
      (setq end        (match-end 0)
            starter    (when (> next 0)
                         (aref format (1- next)))
            terminator (when (< end (length format))
                         (aref format end)))
      (cond ((match-beginning logview--timestamp-group)
             (push nil parts)
             (push 'timestamp features)
             (setq timestamp-at parts))
            ((match-beginning logview--level-group)
             (setq levels (logview--get-split-alists (cdr (assq 'levels definition)) "level mapping"
                                                     logview-additional-level-mappings logview-std-level-mappings))
             (push (format "\\(?%d:%s\\)" logview--level-group
                           (regexp-opt (apply 'append (mapcar (lambda (final-level) (cdr (assq final-level levels)))
                                                              logview--final-levels))))
                   parts)
             (push 'level features))
            ((match-beginning logview--message-group)
             (unless (= (match-end logview--message-group) (length format))
               (user-error "Field `MESSAGE' can only be placed at the very end of format string"))
             (setq have-explicit-message t))
            (t
             (dolist (k (list logview--name-group logview--thread-group logview--ignored-group))
               (when (match-beginning k)
                 (push (format "\\(?%s:%s\\)"
                               (if (/= k logview--ignored-group)
                                   (number-to-string k)
                                 "")
                               (cond ((and starter terminator
                                           (or (and (= starter ?\() (= terminator ?\)))
                                               (and (= starter ?\[) (= terminator ?\]))))
                                      ;; See https://github.com/doublep/logview/issues/2
                                      ;; We allow _one_ level of nested parens inside
                                      ;; parenthesized THREAD or NAME.  Allowing more would
                                      ;; complicate regexp even further.  Unlimited nesting
                                      ;; level is not possible with regexps at all.
                                      ;;
                                      ;; 'rx-to-string' is used to avoid escaping things
                                      ;; ourselves.
                                      (rx-to-string `(seq (* (not (any ,starter ,terminator ?\n)))
                                                          (* ,starter (* (not (any ?\n))) ,terminator
                                                             (* (not (any ,starter ,terminator ?\n)))))
                                                    t))
                                     ((and terminator (/= terminator ? ))
                                      (format "[^%c\n]*" terminator))
                                     (terminator
                                      "[^ \t\n]+")
                                     (t
                                      ".+")))
                       parts)
                 (push (if (= k logview--name-group) 'name 'thread) features)))))
      (setq search-from end))
    (when (< search-from (length format))
      (funcall add-text-part search-from nil))
    ;; Unless `MESSAGE' field is used explicitly, behave as if format string ends with whitespace.
    (unless (or have-explicit-message (string-match "[ \t]$" format))
      (push "[ \t]+" parts))
    (setq parts (nreverse parts))
    (when timestamp-at
      ;; Speed optimization: if the submode includes a timestamp, but
      ;; the test line doesn't have even two digits at the expected
      ;; place, don't even loop through all the timestamp options.
      (setcar timestamp-at ".*[0-9][0-9].*")
      (when (and test-line (not (string-match (apply #'concat parts) test-line)))
        (setq cannot-match t)))
    (unless cannot-match
      (dolist (timestamp-option (if timestamp-at timestamp-options '(nil)))
        (let* ((timestamp-pattern (assq 'java-pattern timestamp-option))
               (timestamp-regexp  (if timestamp-pattern
                                      (condition-case error
                                          (apply #'datetime-matching-regexp 'java (cdr timestamp-pattern)
                                                 :locale (cdr (assq 'locale timestamp-option))
                                                 (append (cdr (assq 'datetime-options timestamp-option)) logview--datetime-options))
                                        ;; 'datetime' doesn't mention the erroneous pattern to keep
                                        ;; the error message concise.  Let's do it ourselves.
                                        (error (warn "In Java timestamp pattern '%s': %s"
                                                     (cdr timestamp-pattern) (error-message-string error))
                                               nil))
                                    (cdr (assq 'regexp timestamp-option)))))
          (when (or timestamp-regexp (null timestamp-at))
            (when timestamp-at
              (setcar timestamp-at (format "\\(?%d:%s\\)" logview--timestamp-group timestamp-regexp)))
            (let ((regexp (apply #'concat parts)))
              (when (or (null test-line) (string-match regexp test-line))
                (setq logview--submode-name           name
                      logview--process-buffer-changes t
                      logview--entry-regexp           regexp
                      logview--submode-features       features
                      logview--submode-level-alist    nil)
                (logview--update-mode-name)
                (when (memq 'level features)
                  (dolist (final-level logview--final-levels)
                    (dolist (level (cdr (assoc final-level levels)))
                      (setq logview--submode-level-alist (cons (cons level final-level) logview--submode-level-alist))
                      (let ((filtered-invisibility-spec (make-symbol (format "logview-filtered:%s" level))))
                        (push (cons level (vector (make-symbol (format "logview:%s" level))
                                                  filtered-invisibility-spec
                                                  (intern (format "logview-%s-entry" (symbol-name final-level)))
                                                  (intern (format "logview-level-%s" (symbol-name final-level)))
                                                  (logview--hide-entry-callback filtered-invisibility-spec)
                                                  (logview--show-entry-callback filtered-invisibility-spec)))
                              logview--submode-level-data)))))
                (logview--split-region-into-entries (point-min) (point-max) 'report-progress)
                (add-hook 'after-change-functions 'logview--split-region-into-entries t t)
                (read-only-mode 1)
                (when buffer-file-name
                  (pcase logview-auto-revert-mode
                    (`auto-revert-mode      (auto-revert-mode      1))
                    (`auto-revert-tail-mode (auto-revert-tail-mode 1))))
                (throw 'success nil)))))))))

(defun logview--all-timestamp-formats ()
  (unless logview--all-timestamp-formats-cache
    (let ((start-time (float-time))
          (patterns (make-hash-table :test 'equal :size 1000))
          (uniques  (make-hash-table :test 'equal :size 1000)))
      (dolist (locale (datetime-list-locales t))
        (let ((decimal-separator (char-to-string (datetime-locale-field locale :decimal-separator)))
              last-time-pattern)
          (dolist (time-variant '(:short :medium :long :full))
            (let ((time-pattern (datetime-locale-time-pattern locale time-variant)))
              (unless (string= time-pattern last-time-pattern)
                (setq last-time-pattern time-pattern)
                (when (and (datetime-pattern-includes-second-p 'java time-pattern)
                           (not (datetime-pattern-includes-timezone-p 'java time-pattern)))
                  (let (variants)
                    (dolist (pattern (cons time-pattern
                                           (mapcar (lambda (date-variant) (datetime-locale-date-time-pattern locale date-variant time-variant))
                                                   '(:short :medium :long :full))))
                      (push pattern                                                                                   variants)
                      (push (replace-regexp-in-string "\\<s+\\>" (concat "\\&" decimal-separator "SSS")    pattern t) variants)
                      (push (replace-regexp-in-string "\\<s+\\>" (concat "\\&" decimal-separator "SSSSSS") pattern t) variants))
                    (dolist (pattern variants)
                      (let* ((parts            (datetime-recode-pattern 'java 'parsed pattern))
                             (locale-dependent (datetime-pattern-locale-dependent-p 'parsed parts))
                             (key              (cons pattern (when locale-dependent locale))))
                        (when (or locale-dependent (null (gethash key patterns)))
                          (puthash key
                                   (apply #'datetime-matching-regexp 'parsed parts :locale locale logview--datetime-options)
                                   patterns)))))))))))
      (maphash (lambda (key regexp)
                 (let ((existing (gethash regexp uniques)))
                   (if existing
                       (unless (memq (cdr key) (cdr existing))
                         (push (cdr key) (cdr existing)))
                     (puthash regexp (cons (car key) (list (cdr key))) uniques))))
               patterns)
      (maphash (lambda (regexp key)
                 (push `(,(car key) (regexp . ,regexp)) logview--all-timestamp-formats-cache))
               uniques)
      (let ((inhibit-message t))
        (message "Logview/datetime: built list of %d timestamp regexps in %.3f s" (hash-table-count uniques) (- (float-time) start-time)))))
  logview--all-timestamp-formats-cache)


(defun logview--assert (&rest assertions)
  (unless (logview-initialized-p)
    (user-error "Couldn't determine log format; press C-c C-s to customize relevant options"))
  (dolist (assertion assertions)
    (unless (or (eq assertion 'message) (memq assertion logview--submode-features))
      (user-error (cdr (assq assertion '((level  . "Log lacks entry levels")
                                         (name   . "Log lacks logger names")
                                         (thread . "Log doesn't include thread names"))))))))


(defun logview--maybe-complain-about-movement (direction remaining &optional as-important-entries)
  ;; Using 'equal' since 'remaining' may also be nil.
  (unless (equal remaining 0)
    (user-error (if as-important-entries
                    (if (> direction 0) "No next (visible) as important entry" "No previous (visible) as important entry")
                  (if (> direction 0) "No next (visible) entry" "No previous (visible) entry")))))


(defun logview--match-current-entry ()
  "Match the header of the log entry where the point currently is.

Return value is non-nil on success.  Point is either before or
after the header, i.e. still in the same log entry, but there are
no more guarantees.  Match data is set appropriately for the
header."
  (forward-line 0)
  (or (looking-at logview--entry-regexp)
      (re-search-backward logview--entry-regexp nil t)
      (re-search-forward  logview--entry-regexp nil t)))

(defun logview--match-successive-entries (n &optional only-visible validator)
  "Match N entries after (if N is positive) or before (negative)
the current one.  If N is zero, match just the current entry.

If ONLY-VISIBLE is non-nil, hidden entries are skipped.  If
VALIDATOR is non-nil, entries for which the function returns nil
are skipped too.

Returns the remaining number, i.e. zero if there are enough valid
entries.  If it never found any valid entries, returns nil.
There is no guarantees about point location after the call, but
match data will be set for the last valid matched header."
  (let* ((forward          (> n 0))
         (direction        (cl-signum n))
         (successful-match '(nil)))
    (when (logview--match-current-entry)
      (when (or (null validator) (funcall validator))
        (match-data t successful-match))
      (when (/= n 0)
        (while (and (= (forward-line direction) 0)
                    (if forward
                        (re-search-forward logview--entry-regexp nil t)
                      (or (looking-at logview--entry-regexp)
                          (re-search-backward logview--entry-regexp nil t)))
                    (if (or (and only-visible (invisible-p (match-beginning 0)))
                            (and validator (not (funcall validator))))
                        t
                      (match-data t successful-match)
                      (/= (setq n (- n direction)) 0))))))
    (if (equal successful-match '(nil))
        nil
      (set-match-data successful-match)
      n)))


(defun logview--iterate-entries-forward (callback &optional only-visible validator)
  "Invoke CALLBACK for successive valid log entries forward.
Iteration starts at the current entry and continues forward until
CALLBACK returns nil or end of buffer is reached.

CALLBACK is called with three arguments: beginning of the entry,
end of its first line and its end (the last two are equal unless
the entry spans multiple lines).  CALLBACK may not access match
data and must make sure point and match data are preserved.

If ONLY-VISIBLE is non-nil, hidden entries are skipped.  If
VALIDATOR is non-nil, entries for which the function returns nil
are skipped too.  VALIDATOR is always called with match data set
and point at the beginning of the next line."
  (when (logview--match-current-entry)
    (let ((entry-begin (match-beginning 0))
          (after-first-line)
          (entry-end)
          (limit       (point-max))
          (invalid))
      (while (progn
               (forward-line)
               (setq invalid (or (and only-visible (invisible-p entry-begin))
                                 (and validator    (not (funcall validator)))))
               (setq after-first-line (point)
                     entry-end        (if (re-search-forward logview--entry-regexp nil t)
                                          (match-beginning 0)
                                        limit))
               (when (or invalid (funcall callback entry-begin after-first-line entry-end))
                 (/= (setq entry-begin entry-end) limit)))))))

(defun logview--iterate-entries-backward (callback &optional only-visible validator)
  "Invoke CALLBACK for successive valid log entries backward.
Iteration starts at the previous entry (not the current!) and
continues backward until CALLBACK returns nil or beginning of
buffer is reached.

See `logview--iterate-entries-forward' for details."
  (when (logview--match-current-entry)
    (let ((entry-begin (match-beginning 0))
          (entry-end))
      (while (and (= (forward-line -1) 0)
                  (or (looking-at logview--entry-regexp)
                      (re-search-backward logview--entry-regexp nil t))
                  (progn
                    (setq entry-end   entry-begin
                          entry-begin (match-beginning 0))
                    (forward-line)
                    (or (and only-visible (invisible-p entry-begin))
                        (and validator    (not (funcall validator)))
                        (when (funcall callback entry-begin (point) entry-end)
                          (goto-char entry-begin)))))))))

(defun logview--iterate-successive-entries (n callback &optional only-visible validator)
  (when (/= n 0)
    (let ((direction (cl-signum n)))
      (funcall (if (> n 0) 'logview--iterate-entries-forward 'logview--iterate-entries-backward)
               (lambda (begin after-first-line entry-end)
                 (funcall callback begin after-first-line entry-end)
                 (/= (setq n (- n direction)) 0))
               only-visible validator)))
  n)

(defun logview--iterate-entries-in-region (begin end callback &optional only-visible validator)
  (goto-char (min begin end))
  (let ((limit (max begin end)))
    (logview--iterate-entries-forward (lambda (begin after-first-line end)
                                        (funcall callback begin after-first-line end)
                                        (< end limit))
                                      only-visible validator)))


(defun logview--update-mode-name ()
  (let ((view-name (catch 'found
                     (dolist (view (logview--views))
                       (when (and (or (null (plist-get view :submode)) (string= (plist-get view :submode) logview--submode-name))
                                  (string= (plist-get view :filters) logview--current-filter-text))
                         (throw 'found (plist-get view :name))))
                     (let ((canonical-filter-text (logview--canonical-filter-text logview--current-filter-text)))
                       (dolist (view (logview--views))
                         (when (and (or (null (plist-get view :submode)) (string= (plist-get view :submode) logview--submode-name))
                                    (string= (logview--canonical-filter-text (plist-get view :filters)) canonical-filter-text))
                           (throw 'found (plist-get view :name))))))))
    (setq mode-name (if view-name
                        (format "Logview/%s [%s]" logview--submode-name view-name)
                      (format "Logview/%s" logview--submode-name)))))

(defun logview--update-invisibility-spec ()
  (let ((invisibility-spec '(logview-hidden-entry logview-hidden-details)))
    (if logview--submode-level-alist
        (let ((show        (null logview--min-shown-level))
              (always-show nil))
          (dolist (level-pair logview--submode-level-data)
            (when (equal (car level-pair) logview--min-shown-level)
              (setq show t))
            (when (equal (car level-pair) logview--min-always-shown-level)
              (setq always-show t))
            (unless show
              (push (aref (cdr level-pair) 0) invisibility-spec))
            (unless always-show
              (push (aref (cdr level-pair) 1) invisibility-spec))))
      (push 'logview-filtered invisibility-spec))
    (when logview--hide-all-details
      (push 'logview-details invisibility-spec))
    (setq buffer-invisibility-spec
          (if logview-show-ellipses
              (mapcar (lambda (x) (cons x t)) invisibility-spec)
            invisibility-spec))
    ;; This weird looking command was suggested in
    ;; irc.freenode.net#emacs and seems to force buffer redraw.
    ;; Otherwise change to 'buffer-invisibility-spec' doesn't have
    ;; immediate effect here.
    (force-mode-line-update)))


(defun logview--parse-filters (&optional to-reset)
  ;; As we "leave" current buffer, we need to rebind variables
  ;; locally, so their values are properly transferred.
  (let ((filters logview--current-filter-text)
        min-shown-level
        min-always-shown-level
        non-discarded-lines
        include-name-regexps
        exclude-name-regexps
        include-thread-regexps
        exclude-thread-regexps
        include-message-regexps
        exclude-message-regexps)
    (when (> (length filters) 0)
      (logview--iterate-filter-text-lines
       filters
       (lambda (type line-begin begin end)
         (let ((filter-line       (not (member type '("#" "" nil))))
               (reset-this-filter (member type to-reset)))
           (when reset-this-filter
             (delete-region begin (point)))
           (when (and (not (and filter-line reset-this-filter)) (or non-discarded-lines (not (equal type ""))))
             (push (buffer-substring-no-properties line-begin (point)) non-discarded-lines))
           (when (and filter-line (not reset-this-filter))
             (cond ((string= type "lv")
                    (setq min-shown-level (buffer-substring-no-properties begin end)))
                   ((string= type "LV")
                    (setq min-always-shown-level (buffer-substring-no-properties begin end)))
                   (t
                    (let ((regexp (logview--filter-regexp begin end)))
                      (when (logview--valid-regexp-p regexp)
                        (pcase type
                          ("a+" (push regexp include-name-regexps))
                          ("a-" (push regexp exclude-name-regexps))
                          ("t+" (push regexp include-thread-regexps))
                          ("t-" (push regexp exclude-thread-regexps))
                          ("m+" (push regexp include-message-regexps))
                          ("m-" (push regexp exclude-message-regexps))))))))
           t))))
    (logview--set-min-level min-shown-level min-always-shown-level)
    (setq logview--current-filter-text (apply 'concat (nreverse non-discarded-lines))
          logview--name-filter         (logview--build-filter include-name-regexps    exclude-name-regexps)
          logview--thread-filter       (logview--build-filter include-thread-regexps  exclude-thread-regexps)
          logview--message-filter      (logview--build-filter include-message-regexps exclude-message-regexps))
    (logview--update-mode-name)))

(defun logview--iterate-filter-text-lines (filters callback)
  (with-temp-buffer
    (insert filters)
    (unless (bolp)
      (insert "\n"))
    (goto-char 1)
    (logview--iterate-filter-buffer-lines callback)))

(defun logview--iterate-filter-buffer-lines (callback)
  "Find successive filter specification in the current buffer.
Buffer must be positioned at the start of a line.  Iteration
continues until CALLBACK returns nil or end of buffer is reached.

CALLBACK is called with four arguments: TYPE, LINE-BEGIN, BEGIN,
and END.  TYPE may be a string: \"a+\", \"a-\", \"t+\", \"t-\", \"m+\",
\"m-\", \"lv\" or \"LV\" for valid filter types, \"#\" for comment line
and \"\" for an empty line, or nil to indicate an erroneous line.
BEGIN and END determine filter text boundaries (may span several
lines for message filters.  LINE-BEGIN is the beginnig of the
line where the entry starts; in case of filters this is a few
characters before BEGIN.  Point is positioned at the start of
next line, which is usually one line beyond END."
  (let ((case-fold-search nil)
        line-begin
        begin
        type)
    (while (and (not (eobp))
                (progn
                  (setq line-begin (point)
                        begin      line-begin
                        type       (when (looking-at "\\(lv\\|LV\\|[atm][-+]\\) \\|\\s-*\\(#\\)\\|\\s-*$")
                                     (if (match-beginning 1)
                                         (progn (setq begin (match-end 0))
                                                (match-string 1))
                                       (or (match-string 2) ""))))
                  (forward-line)
                  (when (member type '("m+" "m-"))
                    (while (looking-at "\\.\\. ")
                      (forward-line)))
                  (funcall callback type line-begin begin (if (bolp) (logview--linefeed-back-checked (point)) (point))))))))

(defun logview--canonical-filter-text (filters)
  (let (filter-lines)
    (logview--iterate-filter-text-lines filters
                                        (lambda (type line-begin _begin end)
                                          (unless (member type '(nil "" "#"))
                                            (push (buffer-substring-no-properties line-begin (1+ end)) filter-lines))))
    (apply #'concat (sort filter-lines #'string<))))

(defun logview--build-filter (include-regexp-list exclude-regexp-list)
  (let ((include-regexp (logview--build-filter-regexp include-regexp-list))
        (exclude-regexp (logview--build-filter-regexp exclude-regexp-list)))
    (list (if include-regexp
              (if exclude-regexp
                  (lambda (string) (and (string-match include-regexp string) (not (string-match exclude-regexp string))))
                (lambda (string) (string-match include-regexp string)))
            (when exclude-regexp
              (lambda (string) (not (string-match exclude-regexp string)))))
          include-regexp
          exclude-regexp)))

(defun logview--filter-regexp (begin end)
  (replace-regexp-in-string "\n\\.\\. " "\n" (buffer-substring-no-properties begin end)))

(defun logview--apply-parsed-filters (&optional cancel-explicit-hiding)
  (logview--process-region-entries 1 (1+ (buffer-size)) nil cancel-explicit-hiding
                                   (lambda (begin end) (make-progress-reporter "Filtering..." begin end))))

(defun logview--process-region-entries (region-begin region-end set-up-entries cancel-explicit-hiding reporter-builder)
  (let* ((name-filter            (car logview--name-filter))
         (thread-filter          (car logview--thread-filter))
         (no-name/thread-filters (and (null name-filter) (null thread-filter)))
         (message-filter         (car logview--message-filter))
         (filter-id              (list (cdr logview--name-filter) (cdr logview--thread-filter) (cdr logview--message-filter)))
         ;; Need a copy, since entry matching is always case-sensitive
         ;; (see 'logview--std-matching-and-altering').
         (case-insensitive       case-fold-search))
    (when (or set-up-entries cancel-explicit-hiding (not (equal logview--applied-filter-id filter-id)))
      (logview--std-matching-and-altering
        (save-restriction
          (widen)
          (goto-char region-begin)
          (let ((anchored (logview--match-current-entry)))
            (when (and set-up-entries (or (not anchored) (> (point) region-begin)))
              ;; Asked to set up entries, but the buffer begins with
              ;; or completely consists of text we don't recognize.
              (put-text-property 1 (if anchored (match-beginning 0) (1+ (buffer-size))) 'face      nil)
              (put-text-property 1 (if anchored (match-beginning 0) (1+ (buffer-size))) 'invisible nil))
            (when anchored
              (let* ((reporter           (when reporter-builder (funcall reporter-builder (match-beginning 0) region-end)))
                     (have-timestamp     (memq 'timestamp logview--submode-features))
                     (have-level         (memq 'level     logview--submode-features))
                     (have-name          (memq 'name      logview--submode-features))
                     (have-thread        (memq 'thread    logview--submode-features))
                     (hider              (unless have-level (logview--hide-entry-callback 'logview-filtered)))
                     (shower             (unless have-level (logview--show-entry-callback 'logview-filtered)))
                     (explicit-shower    (when cancel-explicit-hiding (logview--show-entry-callback 'logview-hidden-entry)))
                     (num-hidden         0)
                     (num-visible        0)
                     (match-data-storage '(nil))
                     message-begin
                     matches-name/thread
                     level-data)
                ;; Because 'callback' doesn't get access to match
                ;; data, while 'validator' doesn't know all entry
                ;; limits, we use both and pass 'matches-name/thread'
                ;; from the validator to the callback.
                (logview--iterate-entries-forward
                 (lambda (begin after-first-line end)
                   (when (and set-up-entries (< after-first-line end) have-level)
                     (put-text-property after-first-line end 'face (aref level-data 2))
                     (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end)
                                        'invisible (list (aref level-data 0) 'logview-details)))
                   ;; Remember that 'matches-name/thread' is not the
                   ;; final value, we still need to check if entry's
                   ;; message passes filters.
                   (if (and matches-name/thread
                            (or (null message-filter)
                                ;; Ideally would just match in the
                                ;; buffer itself, but that's probably
                                ;; unsound due to anchors.
                                (prog2
                                    ;; For speed optimization we don't
                                    ;; use 'save-match-data'.
                                    (match-data t match-data-storage)
                                    (let ((case-fold-search case-insensitive))
                                      (funcall message-filter (buffer-substring-no-properties message-begin end)))
                                  (set-match-data match-data-storage))))
                       (unless set-up-entries
                         (funcall (or shower (aref level-data 5)) begin after-first-line end)
                         (setq num-visible (1+ num-visible)))
                     (funcall (or hider (aref level-data 4)) begin after-first-line end)
                     (setq num-hidden (1+ num-hidden)))
                   (when explicit-shower
                     (funcall explicit-shower begin after-first-line end))
                   (when reporter
                     (progress-reporter-update reporter end))
                   ;; Continuing condition.
                   (< end region-end))
                 nil
                 (lambda ()
                   (let ((case-fold-search case-insensitive))
                     (when have-level
                       (setq level-data (cdr (assoc (match-string logview--level-group) logview--submode-level-data))))
                     (when set-up-entries
                       (when have-level
                         ;; Point is guaranteed to be at the start of the next line.
                         (put-text-property (match-beginning 0) (point) 'face (aref level-data 2))
                         (put-text-property (logview--linefeed-back-checked (match-beginning 0)) (logview--linefeed-back (point))
                                            'invisible (list (aref level-data 0)))
                         (add-face-text-property (match-beginning logview--level-group)
                                                 (match-end       logview--level-group)
                                                 (aref level-data 3)))
                       (when have-timestamp
                         (add-face-text-property (match-beginning logview--timestamp-group)
                                                 (match-end       logview--timestamp-group)
                                                 'logview-timestamp))
                       (when have-name
                         (add-face-text-property (match-beginning logview--name-group)
                                                 (match-end       logview--name-group)
                                                 'logview-name))
                       (when have-thread
                         (add-face-text-property (match-beginning logview--thread-group)
                                                 (match-end       logview--thread-group)
                                                 'logview-thread)))
                     (setq message-begin       (match-end 0)
                           matches-name/thread (or no-name/thread-filters
                                                   ;; Since the filters involve regexp matching themselves,
                                                   ;; we need to store log entry parts before calling any.
                                                   (let ((name   (when name-filter   (match-string-no-properties logview--name-group)))
                                                         (thread (when thread-filter (match-string-no-properties logview--thread-group))))
                                                     (and (or (null name)   (funcall name-filter   name))
                                                          (or (null thread) (funcall thread-filter thread)))))))
                   ;; Operate on all entries.
                   t))
                (if set-up-entries
                    (when reporter
                      (progress-reporter-done reporter))
                  (cond ((= num-hidden 0)
                         (message (if (equal filter-id logview--empty-filter-id) "Filters are reset" "Filtering complete, nothing was hidden")))
                        ((= num-visible 0)
                         (message "Filtering complete, all entries were hidden"))
                        (t
                         (message "Filtering complete, %d %s out of %d (%.1f%%) %s hidden"
                                  num-hidden (if (= num-hidden 1) "entry" "entries") (+ num-hidden num-visible)
                                  (/ (* num-hidden 100.0) (+ num-hidden num-visible)) (if (= num-hidden 1) "was" "were")))))))))
      (setq logview--applied-filter-id filter-id)))))

;; FIXME: Resulting regexp will not be valid if any of the options
;;        uses group backreferences (\N) and maybe some other
;;        constructs.
(defun logview--build-filter-regexp (options)
  (when options
    ;; To prevent refiltering on insignificant changes, we enforce
    ;; canonical option ordering and drop any duplicates.
    (mapconcat 'identity (delete-consecutive-dups (sort options 'string<)) "\\|")))


(defun logview--show-entry-callback (hider)
  (lambda (begin after-first-line end)
    (let ((value (get-text-property begin 'invisible)))
      (when (memq hider value)
        (put-text-property (logview--linefeed-back-checked begin) (logview--linefeed-back after-first-line)
                           'invisible (remq hider value))
        (when (> end after-first-line)
          (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end)
                             'invisible (remq hider (get-text-property after-first-line 'invisible))))))))

(defun logview--hide-entry-callback (hider)
  (lambda (begin after-first-line end)
    (let ((value (get-text-property begin 'invisible)))
      (unless (memq hider value)
        (put-text-property (logview--linefeed-back-checked begin) (logview--linefeed-back after-first-line)
                           'invisible (cons hider value))
        (when (> end after-first-line)
          (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end)
                             'invisible (cons hider (get-text-property after-first-line 'invisible))))))))


(defun logview--iterate-split-alists (callback &rest alists)
  (let ((seen (make-hash-table :test 'equal)))
    (dolist (alist alists)
      (dolist (entry alist)
        (unless (gethash (car entry) seen)
          (funcall callback (car entry) (cdr entry))
          (puthash (car entry) t seen)
          (dolist (alias (cdr (assq 'aliases (cdr entry))))
            (puthash alias t seen)))))))

(defun logview--get-split-alists (key type &rest alists)
  ;; If nothing is found: if TYPE is nil, just return nil, else signal
  ;; a user error with TYPE as missing thing description.
  (catch 'found
    (apply 'logview--iterate-split-alists (lambda (name value)
                                            (when (or (equal name key) (member key (cdr (assq 'aliases value))))
                                              (throw 'found value)))
           alists)
    (when type
      (user-error "Unknown %s '%s'" type key))))

(defun logview--views ()
  "Return the list of all defined views.
Each element is a plist with properties :name, :filters and
:submode.  More properties might be defined later.

This list is preserved across Emacs session in
`logview-views-file'."
  (unless logview--views-initialized
    (condition-case error
        (with-temp-buffer
          (insert-file-contents logview-views-file)
          (setq logview--views (logview--parse-view-definitions)))
      (file-missing)
      (file-error
       ;; Pre-26 versions don't have 'file-missing' error.
       (when (or (>= emacs-major-version 26) (file-exists-p logview-views-file))
         (warn "%s" (error-message-string error)))))
    (setq logview--views-initialized t))
  logview--views)

(defun logview--parse-view-definitions (&optional warn-about-garbage)
  (catch 'done
    (let (views
          pending-name
          pending-submode
          filters-from)
      (while t
        (if (or (eobp) (looking-at logview--view-header-regexp))
            (progn (when pending-name
                     (save-excursion
                       (skip-syntax-backward "-" filters-from)
                       (push (list :name pending-name
                                   :submode pending-submode
                                   :filters (buffer-substring-no-properties filters-from (point)))
                             views)))
                   (when (eobp)
                     (throw 'done (nreverse views)))
                   (setq pending-name (match-string-no-properties 2))
                   (forward-line)
                   (if (looking-at logview--view-submode-regexp)
                       (progn (setq pending-submode (match-string-no-properties 2))
                              (forward-line))
                     (setq pending-submode nil))
                   (setq filters-from (point)))
          (when (and warn-about-garbage (null pending-name) (not (looking-at (rx (0+ blank) (opt "#" (0+ nonl)) eol))))
            (if (yes-or-no-p "Non-comment text before the first view will be discarded; continue? ")
                (setq warn-about-garbage nil)
              (keyboard-quit)))
          (forward-line))))))

(defun logview--insert-view-definitions (&optional predicate)
  (dolist (view (logview--views))
    (when (or (null predicate) (funcall predicate view))
      (unless (bobp)
        (insert "\n"))
      (insert "view " (plist-get view :name) "\n")
      (when (plist-get view :submode)
        (insert "submode " (plist-get view :submode) "\n"))
      (insert (plist-get view :filters))
      (unless (bolp)
        (insert "\n")))))

(defun logview--save-views-if-needed ()
  (when logview--views-need-saving
    (with-temp-buffer
      (logview--insert-view-definitions)
      (write-region (point-min) (point-max) logview-views-file nil 'silent)
      (setq logview--views-need-saving nil))))

(defun logview--completing-read (&rest arguments)
  (apply (or logview-completing-read-function
             (if (and (boundp 'ido-mode) (fboundp 'ido-completing-read) ido-mode)
                 #'ido-completing-read
               #'completing-read))
         arguments))



;;; Internal commands meant as hooks.

(defun logview--split-region-into-entries (begin end &optional old-length)
  "Parse log entries in given region.
Optional third argument is to make the function suitable for
`after-change-functions' and is ignored there.  Special value
'report-progress for this argument is treated differently."
  (when logview--process-buffer-changes
    (save-match-data
      (logview--process-region-entries begin end t nil
                                       (when (eq old-length 'report-progress)
                                         (lambda (begin end) (make-progress-reporter "Parsing buffer..." begin end)))))))

(defun logview--buffer-substring-filter (begin end delete)
  "Optionally remove invisible text from the substring."
  (let ((substring (funcall (default-value 'filter-buffer-substring-function) begin end delete)))
    (if logview-copy-visible-text-only
        (let ((chunks)
              (begin 0)
              (end))
          (while begin
            (setq end (next-single-property-change begin 'invisible substring))
            (when (not (invisible-p (get-text-property begin 'invisible substring)))
              (push (substring substring begin end) chunks))
            (setq begin end))
          (apply 'concat (nreverse chunks)))
      substring)))

(defun logview--isearch-filter-predicate (begin end)
  (and (funcall (default-value 'isearch-filter-predicate) begin end)
       (or (not logview-search-only-in-messages)
             (logview--std-matching
               (save-match-data
                 (save-restriction
                   (widen)
                   (goto-char begin)
                   (or (not (logview--match-current-entry))
                       (and (or (>= (match-beginning 0) end)
                                (and (<= (match-end 0) begin)
                                     (or (not (logview--match-successive-entries 1 t))
                                         (>= (match-beginning 0) end))))))))))))

;; Exists for potential future expansion.
(defun logview--kill-emacs-hook ()
  (logview--save-views-if-needed))



;;; Logview Filter Edit mode.

(defvar logview-filter-edit-mode-map
  (let ((map (make-sparse-keymap)))
    (dolist (binding '(("C-c C-c" logview-filter-edit-save)
                       ("C-c C-k" logview-filter-edit-cancel)))
      (define-key map (kbd (car binding)) (cadr binding)))
    map))

(define-derived-mode logview-filter-edit-mode nil "Logview Filters"
  "Major mode for editing filters of a Logview buffer."
  (logview-filter-edit--font-lock-region (point-min) (point-max))
  (add-hook 'after-change-functions 'logview-filter-edit--font-lock-region t t))

(defun logview-filter-edit-save ()
  (interactive)
  (logview-filter-edit--quit t))

(defun logview-filter-edit-cancel ()
  (interactive)
  (logview-filter-edit--quit nil))

(defun logview-filter-edit--quit (save)
  (let* ((parent  logview-filter-edit--parent-buffer)
         (windows logview-filter-edit--window-configuration)
         (do-quit (lambda ()
                    (kill-buffer)
                    (switch-to-buffer parent)
                    (set-window-configuration windows))))
    (if logview-filter-edit--editing-views
        (progn (when save
                 (let ((new-views (save-excursion
                                    (goto-char 1)
                                    (logview--parse-view-definitions t))))
                   (if logview-filter-edit--editing-views-for-submode
                       (let ((combined-views (nreverse new-views)))
                         (dolist (view (logview--views))
                           (unless (equal (plist-get view :submode) logview-filter-edit--editing-views-for-submode)
                             (push view combined-views)))
                         (setq logview--views (nreverse combined-views)))
                     (setq logview--views             new-views
                           logview--views-need-saving t))))
               (funcall do-quit)
               ;; This takes effect only after quitting.
               (logview--update-mode-name))
      (let ((filters (when save
                       (buffer-substring-no-properties 1 (1+ (buffer-size))))))
        (funcall do-quit)
        (when save
          (when (string-prefix-p logview-filter-edit--filters-hint-comment filters)
            (setq filters (substring filters (length logview-filter-edit--filters-hint-comment))))
          (setq logview--current-filter-text filters)
          (logview--parse-filters)
          (logview--apply-parsed-filters))))))

(defun logview-filter-edit--initialize-text (&optional filters-text)
  (delete-region 1 (1+ (buffer-size)))
  (if logview-filter-edit--editing-views
      (progn (insert logview-filter-edit--views-hint-comment)
             (logview--insert-view-definitions (when logview-filter-edit--editing-views-for-submode
                                                 (lambda (view) (string= (plist-get view :submode)
                                                                         logview-filter-edit--editing-views-for-submode)))))
    (unless (string-prefix-p logview-filter-edit--filters-hint-comment filters-text)
      (insert logview-filter-edit--filters-hint-comment))
    (insert filters-text)
    (unless (bolp)
      (insert "\n")))
  ;; Put cursor at the first filter beginning if possible.
  (goto-char 1)
  (logview--iterate-filter-buffer-lines (lambda (type _line-begin begin _end)
                                          (if (member type logview--valid-filter-prefixes)
                                              (progn (goto-char begin) nil)
                                            t)))
  (set-buffer-modified-p nil))

(defun logview-filter-edit--font-lock-region (region-begin region-end &optional _old-length)
  (save-excursion
    (save-match-data
      (save-restriction
        (with-silent-modifications
          (widen)
          (goto-char region-begin)
          (forward-line 0)
          ;; Never try to parse from the middle of a multiline filter.
          (while (and (not (bobp))
                      (looking-at "\.\. "))
            (forward-line -1))
          (logview--iterate-filter-buffer-lines
           (lambda (type line-begin begin end)
             (cond ((null type)
                    (unless (when logview-filter-edit--editing-views
                              (save-excursion
                                (goto-char line-begin)
                                (cond ((looking-at logview--view-header-regexp)
                                       (put-text-property (match-beginning 1) (match-end 1) 'face 'font-lock-keyword-face)
                                       (put-text-property (match-beginning 2) (match-end 2) 'face 'font-lock-function-name-face)
                                       t)
                                      ((looking-at logview--view-submode-regexp)
                                       (put-text-property (match-beginning 1) (match-end 1) 'face 'font-lock-keyword-face)
                                       (let ((submode-name (match-string-no-properties 2)))
                                         (put-text-property (match-beginning 2) (match-end 2) 'face (if (or (assoc submode-name logview-std-submodes)
                                                                                                            (assoc submode-name logview-additional-submodes))
                                                                                                        'font-lock-variable-name-face
                                                                                                      'error)))
                                       t))))
                      (put-text-property begin end 'face 'error)))
                   ((string= type "#")
                    (put-text-property begin end 'face 'font-lock-comment-face))
                   ((string= type "")
                    (put-text-property begin end 'face nil))
                   ((or (string= type "lv") (string= type "LV"))
                    (put-text-property line-begin begin 'face 'logview-edit-filters-type-prefix)
                    (let ((level-string (buffer-substring-no-properties begin end))
                          (known-levels (with-current-buffer logview-filter-edit--parent-buffer
                                          logview--submode-level-alist)))
                      (while (and level-string known-levels)
                        (if (string= (caar known-levels) level-string)
                            (setq level-string nil)
                          (setq known-levels (cdr known-levels))))
                      (put-text-property begin end 'face (if level-string 'error nil))))
                   (t
                    (let* ((valid (logview--valid-regexp-p (logview--filter-regexp begin end))))
                      (goto-char begin)
                      (while (let ((from (point)))
                               (put-text-property (- from 3) from 'face 'logview-edit-filters-type-prefix)
                               (forward-line)
                               (put-text-property from (if (bolp) (logview--linefeed-back (point)) (point))
                                                  'face (unless valid 'error))
                               (when (< (point) end)
                                 (forward-char 3)
                                 t))))))
             (< (point) region-end))))))))


(add-hook 'kill-emacs-hook 'logview--kill-emacs-hook)
(run-with-idle-timer 30 t 'logview--save-views-if-needed)


(provide 'logview)

;;; logview.el ends here
