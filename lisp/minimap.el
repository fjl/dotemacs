;;; minimap.el --- Minimap sidebar for Emacs

;; Copyright (C) 2011 Dustin Lacewell
;; Copyright (C) 2014 Felix Lange

;; Authors: Felix Lange <br@twurst.com>
;;          Dustin Lacewell <dlacewell@gmail.com>
;;          David Engster <dengste@eml.cc>
;; Keywords: minimap
;; X-Original-Version: 0.1

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Heavily based off minimap.el by David Engster however I
;; have refactored it a bit to support only a single global
;; minimap window. Usually this should be opened on startup
;; when there is a single window. Some defaults have also
;; been changed.

;; This file is an implementation of a minimap sidebar, i.e., a
;; smaller display of the current buffer on the left side. It
;; highlights the currently shown region and updates its position
;; automatically. You can navigate in the minibar by dragging the
;; active region with the mouse, which will scroll the corresponding
;; edit buffer.

;; Usage:
;;  * Put minimap.el in your load path.
;;  * (require 'minimap)
;;  * Use 'M-x minimap-toggle' to toggle the minimap.
;;  * Use 'M-x minimap-create' to create the minimap.
;;  * Use 'M-x minimap-kill' to kill the minimap.
;;  * Use 'M-x customize-group RET minimap RET' to adapt minimap to your needs.

;;; Customizable variables;

(defgroup minimap nil
  "A minimap sidebar for Emacs."
  :group 'convenience)

(defface minimap-active-region-background
  '((((background dark)) (:background "#4517305D0000"))
    (t (:background "#C847D8FEFFFF")))
  "Face for the active region in the minimap.
By default, this is only a different background color."
  :group 'minimap)

(defface minimap-semantic-function-face
  '((((background dark))
     (:box (:line-width 1 :color "white")
           :inherit (font-lock-function-name-face minimap-font-face)
           :height 1.9 :background "gray10"))
    (t (:box (:line-width 1 :color "black")
             :inherit (font-lock-function-name-face minimap-font-face)
             :height 1.9 :background "gray90")))
  "Face used for functions in the semantic overlay.")

(defface minimap-semantic-variable-face
  '((((background dark))
     (:box (:line-width 1 :color "white")
           :inherit (font-lock-variable-name-face minimap-font-face)
           :height 1.9 :background "gray10"))
    (t (:box (:line-width 1 :color "black")
             :inherit (font-lock-function-name-face minimap-font-face)
             :height 1.9 :background "gray90")))
  "Face used for variables in the semantic overlay.")

(defface minimap-semantic-type-face
  '((((background dark))
     (:box (:line-width 1 :color "white")
           :inherit (font-lock-type-face minimap-font-face)
           :height 1.9 :background "gray10"))
    (t (:box (:line-width 1 :color "black")
             :inherit (font-lock-function-name-face minimap-font-face)
             :height 1.9 :background "gray90")))
  "Face used for types in the semantic overlay.")

(defcustom minimap-pixel-width 100
  "Width of minimap sidebar window (in pixels)."
  :type 'number
  :group 'minimap)

(defcustom minimap-side 'right
  "Side on which the minimap window is displayed."
  :type '(choice (const :tag "On the left side" 'left)
                 (const :tag "On the right side" 'right))
  :group 'minimap)

(defcustom minimap-buffer-name-prefix " *MINIMAP*"
  "Prefix for buffer names of minimap sidebar."
  :type 'string
  :group 'minimap)

(defcustom minimap-display-semantic-overlays t
  "Display overlays from CEDET's semantic analyzer.
If you use CEDET and the buffer's major-mode is supported, the
minimap can display overlays generated by the semantic analyzer.
By default, it will apply the faces `minimap-semantic-<X>-face',
with <X> being \"function\", \"variable\" and \"type\".  Also, it
will display the name of the tag in the middle of the overlay in
the corresponding font-lock face.

See also `minimap-enlarge-certain-faces', which can be used as
fallback."
  :type 'boolean
  :group 'minimap)

(defcustom minimap-enlarge-certain-faces 'as-fallback
  "Whether certain faces should be enlarged in the minimap.
All faces listed in `minimap-normal-height-faces' will be
displayed using the default font height, allowing you to still
read text using those faces.  By default, this should enlarge all
function names in the minimap, given you have font locking
enabled.  This variable can have the following values:

'as-fallback (the default) -- The feature will only be activated
  if information from CEDET's semantic analyzer isn't available
  (see: `minimap-display-semantic-overlays').
'always -- Always active.
nil -- Inactive."
  :type '(choice (const :tag "Fallback if CEDET unavailable." 'as-fallback)
                 (const :tag "Always active." 'always)
                 (const :tag "Inactive." nil))
  :group 'minimap)

(defcustom minimap-normal-height-faces '(font-lock-function-name-face)
  "List of faces which should be displayed with normal height.
When `minimap-enlarge-certain-faces' is non-nil, all faces in
this list will be displayed using the default font height.  By
default, this list contains `font-lock-function-name-face', so
you can still read function names in the minimap."
  :type '(repeat face)
  :group 'minimap)

(defcustom minimap-sync-overlay-properties '(face invisible)
  "Specifies which overlay properties should be synced.
Unlike text properties, overlays are not applied automatically to
the minimap and must be explicitly synced.  This variable
specifies which overlay properties should be synced by
`minimap-sync-overlays'.  Most importantly, this variable should
include 'invisible', so that hidden text does not appear in the
minimap buffer."
  :type '(repeat symbol)
  :group 'minimap)

(defcustom minimap-resizes-buffer nil
  "Whether or not the currently active window should be resized.
When a minimap buffer is toggled, this option will permit or deny
the ability for the Minimap mode to resize the window you are
working in."
  :type 'boolean
  :group 'minimap)

;;; Internal variables
(defvar minimap-window nil)

(defvar minimap-start 0)
(defvar minimap-end 0)
(defvar minimap-active-overlay nil)
(mapc #'make-variable-buffer-local
      '(minimap-start minimap-end minimap-active-overlay))

;;;###autoload
(defun minimap-toggle ()
  "Turn the minimap on or off."
  (interactive)
  (if (and minimap-window (window-live-p minimap-window))
      (minimap-off)
    (minimap-on)))

;;;###autoload
(defun minimap-on ()
  "Show the minimap window."
  (interactive)
  (unless (and minimap-window (window-live-p minimap-window))
    (setq minimap-window (minimap-make-window))
    (add-hook 'post-command-hook 'minimap-schedule-update)
    (minimap-update)))

;;;###autoload
(defun minimap-off ()
  "Kill the minimap window and all internal buffers."
  (interactive)
  (if (null minimap-window)
      (message "No minimap window found.")
    (when (minimap-buffer-p (window-buffer minimap-window))
      (delete-window minimap-window)
      (message "Minimap killed."))
    (setq minimap-window nil)
    (dolist (b (buffer-list))
      (when (minimap-buffer-p b)
        (kill-buffer b)))))

(defun minimap-buffer-name (&optional buffer)
  "Get minimap buffer name for current buffer"
  (concat minimap-buffer-name-prefix " " (buffer-name buffer)))

(defun minimap-make-window ()
  "Create a new window for the minimap."
  (let* ((size (- minimap-pixel-width))
         (side (if (eq 'left minimap-side) 'left 'right))
         (ignore-window-parameters t)
         (window (split-window (frame-root-window) size side t)))
    (unless window
      (error "Failed to create window. Try `delete-other-windows' (C-x 1) first."))
    (set-window-fringes window 0 0)
    window))

(defun minimap-get-buffer (&optional target-buf)
  "Create new minimap indirect-buffer pointing to TARGET."
  (unless target-buf (setq target-buf (current-buffer)))
  (let ((name (minimap-buffer-name target-buf)))
    (or (get-buffer name)
        ;; create a new one
        (let ((buffer (make-indirect-buffer target-buf name t))
              (target-win (selected-window)))
          (with-current-buffer buffer
            (text-scale-set -10)
            (setq minimap-start (window-start target-win)
                  minimap-end (window-end target-win t)
                  minimap-active-overlay (make-overlay minimap-start minimap-end)
                  line-spacing -8
                  truncate-lines t
                  buffer-read-only t
                  mode-line-format (and mode-line-format "")
                  header-line-format nil
                  buffer-display-table (make-display-table))
            ;; disable $ at the end of truncated lines
            (set-display-table-slot buffer-display-table 0 ?\ )
            ;; create overlays
            (overlay-put minimap-active-overlay 'face 'minimap-active-region-background)
            (overlay-put minimap-active-overlay 'priority 5)
            ;; modes
            (minimap-mode 1)
            (when (and (boundp 'linum-mode) linum-mode)
              (linum-mode 0)))
          buffer))))

(defun minimap-valid-target (&optional buffer)
  "Return t if valid minimap target"
  (and (not (minimap-buffer-p buffer)) (not (minibufferp buffer))))

(defun minimap-buffer-p (&optional buffer)
  "Return t if the given buffer is a minimap buffer."
  (string-prefix-p minimap-buffer-name-prefix
                   (if (stringp buffer) buffer (buffer-name buffer))))

(defun minimap-schedule-update ()
  "Schedule an update of the minimap. Installed as a `post-command-hook'."
  (when (and minimap-window
             (window-live-p minimap-window)
             (not (eq (selected-window) minimap-window))
             (minimap-valid-target))
    (minimap-update)))
    ;; Optimization idea (limit updates):
    ;; (unless (timer-set-time
    ;;   (setq minimap-update-timer (run-at-time 0.020 nil 'minimap-update)))))
  
(defun minimap-update ()
  (let* ((cur (window-buffer minimap-window))
         (buf (minimap-get-buffer)))
    ;; update tracked buffer
    (unless (eq buf cur)
      (set-window-dedicated-p minimap-window nil)
      (set-window-buffer minimap-window buf t)
      ;; (when (minimap-buffer-p cur)
      ;;   (kill-buffer cur))
      (set-window-dedicated-p minimap-window t))
    ;; update overlay and recenter
    (let ((start (window-start))
          (end (window-end nil t)))
      (when (and end
                 (/= start (buffer-local-value 'minimap-start buf))
                 (/= end (buffer-local-value 'minimap-end buf)))
        (with-selected-window minimap-window
          (move-overlay minimap-active-overlay start end buf)
          (setq minimap-start start
                minimap-end end)
          (minimap-recenter start end))))))

;;; Overlay movement

(defun minimap-move-overlay-mouse (start-event)
  "Move overlay by tracking mouse movement."
  (interactive "e")
  (mouse-set-point start-event)
  (when (get-buffer-window (buffer-base-buffer (current-buffer)))
    (let* ((echo-keystrokes 0)
           (end-posn (event-end start-event))
           (start-point (posn-point end-posn))
           (make-cursor-line-fully-visible nil)
           (cursor-type nil)
           (pcselmode (when (boundp 'pc-selection-mode)
                        pc-selection-mode))
           pt ev)
      (when (and pcselmode (fboundp 'pc-selection-mode))
        (pc-selection-mode -1))
      (move-overlay minimap-active-overlay start-point minimap-end)
      (track-mouse
        (minimap-set-overlay start-point)
        (while (and
                (consp (setq ev (read-event)))
                (eq (car ev) 'mouse-movement))
          (setq pt (posn-point (event-start ev)))
          (when (numberp pt)
            (minimap-set-overlay pt))))
      (select-window (get-buffer-window (buffer-base-buffer)))
      (when (and pcselmode (fboundp 'pc-selection-mode))
        (pc-selection-mode 1)))))

(defun minimap-set-overlay (pt)
  "Set overlay position, with PT being the middle."
  (goto-char pt)
  (let* ((ovstartline (line-number-at-pos minimap-start))
         (ovendline (line-number-at-pos minimap-end))
         (ovheight (round (/ (- ovendline ovstartline) 2)))
         (line (line-number-at-pos))
         (winstart (window-start))
         (winend (window-end))
         newstart newend)
    (setq pt (point-at-bol))
    (setq newstart (minimap-line-to-pos (- line ovheight)))
    ;; Perform recentering
    ;; (minimap-recenter line ovheight)
    ;; Set new position in main buffer and redisplay
    (with-selected-window (get-buffer-window (buffer-base-buffer))
      (goto-char pt)
      (set-window-start nil newstart)
      (redisplay t)
      (setq newend (window-end)))
    (move-overlay minimap-active-overlay newstart newend)))

(defun minimap-line-to-pos (line)
  "Return point position of line number LINE."
  (save-excursion
    (goto-char 1)
    (if (eq selective-display t)
        (re-search-forward "[\n\C-m]" nil 'end (1- line))
      (forward-line (1- line)))
    (point)))

(defun minimap-recenter (start end)
  "Recenter the minimap.
MIDDLE is the line number in the middle of the active region.
HEIGHT is the number of lines from MIDDLE to begin/end of the
active region."
  (let* ((buf-lines  (count-lines 1 (buffer-size)))
         (win-lines  (window-buffer-height minimap-window))
;;         (percent    (/ (float buf-lines) (float (line-number-at-pos))))
;;         (win-offset (floor (* win-lines percent)))
         (pages (/ buf-lines win-lines))
;;         (page-offset (mod (line-) win-lines))
         )
    (recenter (+ (* pages win-lines) (/ win-lines 2)))))

;; (defun minimap-recenter (middle height)
;;   "Recenter the minimap.
;; MIDDLE is the line number in the middle of the active region.
;; HEIGHT is the number of lines from MIDDLE to begin/end of the
;; active region."
;;   (let* ((maxlines (line-number-at-pos (point-max)))
;;          (numlines (count-lines (window-start) (window-end)))
;;          (percentage (/ (float middle) (float maxlines)))
;;          (newline (ceiling (* percentage numlines)))
;;          (start (minimap-line-to-pos
;;                  (- middle height
;;                     (floor (* percentage (- numlines height height)))))))
;;     (or (> start (point-min))
;;         (setq start (point-min)))
;;     ;; If (point-max) already visible, don't go further
;;     (if (and (> start (window-start))
;;              (with-selected-window (get-buffer-window (buffer-base-buffer))
;;                (= (point-max) (window-end))))
;;         (save-excursion
;;           (goto-char (point-max))
;;           (recenter -1))
;;       (unless (and (> start (window-start))
;;                    (= (point-max) (window-end)))
;;         (set-window-start nil start)))))

;;; satellite minor mode

(defvar minimap-mode-map (make-sparse-keymap)
  "Keymap used by `minimap-mode'.")

(define-key minimap-mode-map [down-mouse-1] 'minimap-move-overlay-mouse)
(define-key minimap-mode-map [down-mouse-2] 'minimap-move-overlay-mouse)
(define-key minimap-mode-map [down-mouse-3] 'minimap-move-overlay-mouse)

(define-minor-mode minimap-mode
  "Minor mode for minimap sidebar."
  nil "minimap" minimap-mode-map)

;;; Sync minimap with modes which create/delete overlays.

(defun minimap-sync-overlays ()
  "Synchronize overlays between base and minimap buffer.
Apply semantic overlays or face enlargement if necessary."
  (interactive)
  (let ((baseov (overlays-in (point-min) (point-max)))
        (semantic (and (boundp 'semantic-version)
                       (semantic-active-p)))
        ov props p)
    (set-window-dedicated-p minimap-window nil)
    (with-current-buffer (minimap-buffer-name)
      (remove-overlays)
      (while baseov
        (when (setq props (minimap-get-sync-properties (car baseov)))
          (setq ov (make-overlay (overlay-start (car baseov))
                                 (overlay-end (car baseov))))
          (while (setq p (car props))
            (overlay-put ov (car p) (cadr p))
            (setq props (cdr props))))
        (setq baseov (cdr baseov))))
    ;; Face enlargement
    (when (and font-lock-mode
               (or (eq minimap-enlarge-certain-faces 'always)
                   (and (eq minimap-enlarge-certain-faces 'as-fallback)
                        (or (not minimap-display-semantic-overlays)
                            (not semantic)))))
      (when (eq font-lock-support-mode 'jit-lock-mode)
        (jit-lock-fontify-now))
      (with-current-buffer (minimap-buffer-name)
        (minimap-enlarge-faces)))
    ;; Semantic overlays
    (when (and semantic
               minimap-display-semantic-overlays)
      (minimap-apply-semantic-overlays))))

(defun minimap-get-sync-properties (ov)
  "Get properties from overlay OV which should be synced.
You can specify those properties with
`minimap-sync-overlay-properties'."
  (delq nil
        (mapcar
         (lambda (p)
           (let ((val (overlay-get ov p)))
             (if val
                 (list p val)
               nil)))
         minimap-sync-overlay-properties)))

(defun minimap-enlarge-faces ()
  "Apply default font to all faces in `minimap-normal-height-faces'.
This has to be called in the minimap buffer."
  (let ((pos (next-single-property-change (point-min) 'face))
        next ov face)
    (while pos
      (setq face (get-text-property pos 'face))
      (when (delq nil (mapcar (lambda (x) (equal x face))
                              minimap-normal-height-faces))
        (setq ov
              (make-overlay pos
                            (setq pos (next-single-property-change pos 'face))))
        (overlay-put ov 'face `(:family ,(face-font 'default)))
        (overlay-put ov 'priority 5))
      (setq pos (next-single-property-change pos 'face)))))

(defun minimap-apply-semantic-overlays ()
  "Apply semantic overlays to the minimap.
This has to be called from the base buffer."
  (let ((tags (semantic-fetch-tags))
        tag class ov ovnew)
    (while tags
      (setq tag (car tags))
      (setq class (semantic-tag-class tag))
      (setq ov (semantic-tag-overlay tag))
      (when (and (overlayp ov)
                 (or (eq class 'function)
                     (eq class 'type)
                     (eq class 'variable)))
        (message (minimap-buffer-name))
        (with-current-buffer (minimap-buffer-name)
          (let ((start (overlay-start ov))
                (end (overlay-end ov))
                (name (semantic-tag-name tag)))
            (overlay-put
             (setq ovnew (make-overlay start end))
             'face `(:background ,(face-background
                                   (intern (format "minimap-semantic-%s-face"
                                                   (symbol-name class))))))
            (overlay-put ovnew 'priority 1)
            (setq start
                  (minimap-line-to-pos (/ (+ (line-number-at-pos start)
                                             (line-number-at-pos end)) 2)))
            (setq end (progn (goto-char start) (point-at-eol)))
            (setq ovnew (make-overlay start end))
            (overlay-put ovnew 'face (format "minimap-semantic-%s-face"
                                             (symbol-name class)))
            (overlay-put ovnew 'display (concat "  " name "  "))
            (overlay-put ovnew 'priority 6))))
      (setq tags (cdr tags)))))

;; outline-(minor-)mode
;; (add-hook 'outline-view-change-hook 'minimap-sync-overlays)

;; hideshow
;; (add-hook 'hs-hide-hook 'minimap-sync-overlays)
;; (add-hook 'hs-show-hook 'minimap-sync-overlays)

(provide 'minimap)
